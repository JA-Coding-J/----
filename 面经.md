# JS 基础
## Map 和 object 的不同
- **意外的键**；Map 默认情况不包含任何键。只包含显示插入的键。而 Object 有一个原型，原型链上的所有键名有可能和自己在对象上设置的键名冲突。
- **键的类型上**；Map 的 key 值可以使用任何 JavaScript 数据类型作为 key；而 Object 必须是字符串或 Symbol 作为 key。
- **键的顺序**；Map 的键是有序的，因此当迭代的时候，一个 Map 对象以插入的顺序返回键值；而 Object 的键目前是有序的，但不总是这样，而且它的顺序逻辑是比较复杂的，最好不要依赖于 Object 迭代属性的顺序
- **键值个数计算**；Map 的键值个数可以轻易通过 size 获取；而 Object 的键值个数只能手动计算
- **迭代**；Map 是可迭代的，所以可以直接迭代；而 Object 没有实现迭代，所以使用 `for of` 表达式并不能直接迭代对象。
- **性能**；Map 在频繁增删键值的场景下表现更好；Object 没有做出优化
- **序列化和解析**；Map 没有元素的序列化和解析支持，但是可以使用携带 *replacer* 参数的 `JSON.stringify()` 创建一个自己的对 Map 序列化和解析支持；原生支持由 Object 到 JSON 序列化。

## Map、WeakMap、Set 和 WeakSet 的区别
- Map 的 key 值可以是任何 JavaScript 的数据类型
- WeakMap 的 key 值只能是引用类型，并且是弱引用，垃圾回收机制不考虑 WeakMap 的引用；键值可以是随机的，无法遍历
- Set 的值可以是任何 JavaScript 的数据类型
- WeakSet 只能存储对象引用，且都是弱引用，垃圾回收机制不考虑 WeakSet 对对象的引用；另外 WeakSet 对象是无法遍历的，也无法去到它包含的元素

## 闭包、原型、原型链、作用域链和继承
### 作用域链
每个函数调用都有自己的上下文，在调用一个函数时，会将这个函数的**上下文**推到一个上下文栈上，并创建一个**作用域链**。然后用 arguments 和其他命名参数来初始化这个函数的**活动对象**。外部函数的活动对象是内部函数作用域链上的第二个对象。这个作用域链一直向外串起了所有包含函数的活动对象，直到**全局执行上下文**才终止。

每个上下文都有一个关联的**变量对象**，而这个上下文中定义的所有变量和函数都存在于这个变量对象上，但是无法通过代码访问变量对象。
每个函数调用都有自己的上下文。当代码执行流进入函数时，函数的上下文被推到一个上下文栈上。在函数执行完之后，上下文栈会弹出该函数上下文，将控制权还给之前的执行上下文。
上下文中的代码在执行时，会创建变量对象的一个**作用域链**。这个作用域链**决定了各级上下文中的代码在访问变量和函数时的顺序**。代码正在执行的上下文的变量对象始终位于作用域链的最前端。如果上下文是函数，则其**活动对象**用作变量对象。活动对象最初只有一个定义变量：arguments。作用域链中的下一个变量对象来自包含上下文，再下一个对象来自下一个包含上下文。以此类推到全局上下文。
代码执行时的**标识符**解析通过沿作用域链逐级搜索标识符名称完成。搜索过程始终从作用域链的最前端开始，逐级往后直到找到标识符。

### 原型链
原型链定义为 ECMAScript 的主要继承方式。其基本思想就是**通过原型继承多个引用类型的属性和方法**。
每个构造函数都有一个原型对象，原型对象有一个属性 `constructor` 指回构造函数，而实例有一个内部指针 `__proto__` 指向原型。如果一个原型是另一个类型的实例，那就意味着这个原型本身有一个内部指针 `__proto__` 指向另一个原型，相应地另一个原型也会有一个指针指向它的构造函数。这样就在实例和原型之间构造了一条原型链。
        
### 闭包

闭包指的是那些引用了另一个**函数作用域**中变量的函数，通常是在嵌套函数中实现的。

在调用一个函数时，会为这个函数调用创建一个**执行上下文**，并创建一个**作用域链**。然后用 arguments 和其他命名参数来初始化这个函数的**活动对象**。外部函数的活动对象是内部函数作用域链上的第二个对象。这个作用域链一直向外串起了所有包含函数的活动对象，直到全局执行上下文才终止。

调用函数 --创建--> 执行上下文、作用域链 ----> 用 arguments 和其他命名参数来初始化函数的活动对象

函数内部的代码在访问变量时，就会使用给定的名称从作用域链中查找变量。在函数执行完毕后，局部活动对象会被销毁，内存中就只剩下全局作用域。不过，闭包就不一样了。在一个函数内部定义的函数会把其包含函数的**活动对象**添加到自己的作用域链中。

因为闭包会保留它们包含函数的作用域，所以比其他函数更占用内存。过度使用闭包可能导致内存过度占用以及**栈溢出**。

**内存泄漏**

内部函数引用了包含函数的引用变量 a，导致 a 的引用计数至少是 1，内存不会被回收，导致内存问题。

**使用场景**

任何闭包的使用场景都离不开两点：

- 创建私有变量
- 延长变量的生命周期
- 柯里化函数
- 早期用来实现 JS 模块化:
JS 模块：具有特定功能的 js 文件，将所有的数据和功能封装在一个函数内部（私有的），只向外暴露一个包含多个对象或函数，模块的使用者，只能通过模块暴露的对象调用方法来实现相应的功能。
            
### 继承
1. 原型链
      		
	``` js
	    function SuperType() {
	        this.property = true
	        this.colors = []
	    }
	    SuperType.prototype.getValue = function () {
	        return this.property
	    }
	    function SubType() {
	        this.subProperty = false;
	    }
	    SubType.prototype = new SuperType()
	    SubType.prototype.getSubValue = function () {
	        return this.subProperty
	    }
	```
	
	- 优点：
	  - 易于实现
	  - 子类能访问到父类的原型属性
	- 缺点：
	  - 父类实例引用属性共享问题
	  - 子类在实例化的时候不能给父类传参。事实上，我们无法在不影响所有子类实例的情况下将参数传给父类构造函数。

2. 盗用构造函数

	```js
	    function SuperType(name) {
	        this.name = name
	    }
	    function SubType() {
	        SuperType.call(this, "Nicholas")
	        this.subProperty = false
	    }
	```
	
	- 优点：
	  - 解决了原型链继承中子类实例**共享父类引用属性**的问题
	  - 创建子类实例时可以给父类传参
	  - 可以实现**多继承**
	- 缺点
	  - 原型链没接上，子类无法访问父类原型属性，因此所有属性必须在构造函数中定义方法，也就是**构造函数模式**，因此函数不能重用。

3. 组合继承: 组合继承是原型链和盗用构造函数的组合
	
	```js
	    function SuperType(name) {
	        this.name = name
	        this.colors = []
	    }
	    SuperType.prototype.getValue = function () {
	        return this.name
	    }
	    function SubType(name, age) {
	        SuperType.call(this, name)
	        this.age = age
	    }
	    SubType.prototype = new SuperType()
	    SubType.prototype.getAge = function () {
	        return this.age
	    }
	```
	
	- 优点：
	  - 不存在父类引用属性共享问题
	  - 可以给父类传参
	  - 函数属性可以共享
	- 缺点：
	  - 调用了两次父类构造函数

4. 原型式继承

	适用情况：有一个对象，你想在它的基础上再创建一个新对象。你需要把这个对象先传给 object(), 然后再对返回的对象进行适当修改，即适用于获取在源对象基础上对部分属性进行修改后的副本。
	
	```js
	    // 与 Object.create(o, extendObj) 效果相同
	    function object(o, extendObj) {
	        function F() {}
	        F.prototype = o
	        return Object.assign(new F(), extendObj) // f.__proto__ = o
	    }
	    let person = {
	        name: "Nicholas",
	        friends: ["Shelby"]
	    }
	    let anotherPerson = object(person)
	    anotherPerson.name = "Greg"
	    anotherPerson.friends.push("Rob")
	    person.friends // "shelby", "Rob"
	```
	
	- 优点：
	- 缺点：
	  - 本质是源对象的浅拷贝
	  - 存在引用属性共享问题

5.  寄生式继承
	
	背后的思路类似于**寄生构造函数**和**工厂模式**：创建一个实现继承的函数，以某种方式**增强对象**，然后返回这个对象。
	
	```js
	    function createAnother(origin) {
	        let clone = Object.create(origin) // 创建一个新对象
	        clone.sayHi = function() {      // 以某种方式**增强**这个对象
	            console.log('hi')
	        }
	    }
	    let person = {
	        name: "Nicholas",
	        age: "28"
	    }
	    let anotherPerson = createAnother(person)
	    anotherPerson.sayHi() // 'hi'
	```
	
	缺点：函数难以复用，与构造函数模式类似
        
6.  寄生组合式继承

    ```js
        function inheritPrototype(Sub, Super) {
            let subPrototype = object(Super.prototype) // 创建对象，连接父类原型 subProtoType.__proto__ = Super.protoType
            subPrototype.constructor = Sub // 增强对象，子类原型连接构造函数
            Sub.prototype = subPrototype // 赋值对象
        }
        function SuperType(name) {
            this.name = name
            this.colors = ["blue"]
        }
        SuperType.prototype.getName = function () { return this.name }
        function SubType(name, age) {
            SuperType.call(this, name)
            this.age = age
        }
        inheritPrototype(SubType, SuperType)
        SubType.prototype.getAge = function () { return this.age }
    ```
    
    - 优点：
      - 解决了**组合继承**的问题，只调用了一次 SuperType 构造函数；
      - 避免了 SubType.prototype 上不必要也用不到的属性（组合继承方法中，SubType.prototype 继承了 SuperType 的实例属性），因此可以说这种方法的效率更高
      - 原型链仍然保持不变，因此 instanceof 操作符和 isPrototypeof() 方法正常有效

    可以说是引用类型继承的最佳方式
        
7. ES6 继承语法糖

	class 关键字只是原型的语法糖，实际上他背后使用的是**原型**和**构造函数**的概念。
	
	虽然 class 继承使用的是新语法，但背后依旧使用的是**原型链**。
	
	- 优点：
	  - 语法简单易懂，操作方便
	- 缺点：
	  - 并不是所有的浏览器都支持 class 关键字
    
## 微任务、宏任务代码执行顺序的经典问题
await 语句会把修饰的语句放到微任务队列中，Promise 的 then 和 catch 回调会被放到微任务队列中。setTimeout 会被放到宏任务队列中。
  
## 自执行函数的好处？
- 防止命名冲突。
- 拥有自己独立的作用域，避免全局变量的污染。

## 前端模块化

模块是指将一个复杂的程序依据一定的规则（规范）封装成几个块（文件），并进行组合在一起，块的内部数据与实现是私有的，只是向外暴露一些接口（方法）与外部模块进行通信。

- 有哪些模块化方式
  - CommonJS，主要用于服务端编程，加载模块是**同步**的，这并不适合在浏览器环境，因为同步就以为着阻塞加载，浏览器资源是异步加载的，因此有了 AMD 和 CMD 的解决方案。
  - AMD 规范，在浏览器中异步加载模块，并且可以并行加载多个模块。推崇**依赖前置**。缺点是提高了开发成本，并不能按需加载，而是提前加载所有依赖
  - CMD 规范，与 AMD 规范相似，都用于浏览器编程，依赖就近（**按需加载**），延迟执行，可以很容易在 Node.js 中运行
  - ES Module 的设计思想是尽量的静态化，使得编译时就确定模块依赖关系，以及输入和输出的变量。
    - CommonJS 和 AMD 模块，都只能在运行时确定，它们的本质是在运行时生成一个对象进行导出，而 ES Module 不是对象，而是在编译时输出接口。
    - ES Module 输出的是值的引用，而 CommonJS 输出的是值的拷贝。
- 模块化的好处
  - 避免命名冲突；
  - 便于依赖管理；
  - 利于性能优化；
  - 提高可维护性；
  - 提高代码可复用性；

## 函数式编程 - FP(Functional Programming)
1. 纯函数，没有副作用、单一职责，只做一件事
  1. The same input always gives the same output (idempotence - *幂等性*), and has no side effects.
2. 没有副作用以及不可变性
  1. 没有副作用，函数的执行不会影响到函数作用域外
  2. 不可变性，函数的执行不会改变输入，如果函数需要对输入的值进行修改，应该在函数内部进行值的拷贝，再通过拷贝进行操作

高阶组件
组合
声明式编程范式

- **Declarative programming** is a programming paradigm where we specify the program logic without describing the flow control. Declarative programming is all about **what** to do to achieve a certain result.
- **Imperative programming** is a programming paradigm where we specify the program logic describing the flow control. Imperative programming is all about **how** to achieve a certain result.

## 变量提升

`var`会使**变量提升**，这意味着变量可以在声明之前使用。`let` 和 `const` 则不会使变量提升，提前使用会报错。变量提升（hoisting）是用于解释代码中变量声明行为的术语。使用`var`关键词声明或初始化的变量，会将声明语句“提升”到**当前作用域**的顶部。但是，只有声明才会触发提升，赋值语句将保持原样。

## 使用let、var和const创建变量有什么区别

- var 声明的变量会挂载到 window 上，不论是在哪个作用域下，而 let 和 const 声明的变量不会。
- **块级作用域**：用 `var` 声明的变量的作用域是它当前的执行上下文（函数作用域），它可以是嵌套的函数，也可以是声明在任何函数外的变量。`let` 和 `const` 的声明范围是块级作用域，意味着它们只能在最近的一组花括号(`function`, `if-else` 代码块或 `for` 循环)中访问。
- **暂时性死区**：`var` 会使变量提升，这意味着变量可以在声明之前使用。而 `let` 和 `const` 不会使变量提升，在 `let` 声明之前的执行瞬间被称为“暂时性死区”，在此阶段引用任何后面才声明的变量都会抛出 **ReferenceError**。
- **重复声明**：用 `var` 重复声明不会报错，但 `let` 和 `const` 会。
- **全局声明**：与 `var` 不同，使用 `let/const` 在全局作用域中声明的变量不会成为 window 对象的属性。
- `let` 和 `const` 的行为基本一样，唯二重要的区别在于： `let` 允许多次赋值，而 `const` 只允许一次，并且使用 `const` 声明变量时必须同时初始化变量，否则会导致运行错误。`SyntaxError: Missing initializer in const declaration`

## Web Worker 了解过吗？
如果在 Worker 中操作 DOM 会发生什么？
首先，Worker 运行在另一个全局上下文中，不同于 window. 在 worker 内，不能直接操作 DOM 节点，也不能使用 window 对象的默认方法和属性，但是可以使用 WebSockets, IndexDB 以及 FireFox OS 专用的 Data Store API 等数据存储机制

workers 和主线程之间的数据传递通过这样的消息机制进行：
双方都是用 postMessage 方法发送各自的消息，使用 onmessage 时间处理函数来相应消息。这个过程中数据并不是被共享而是被复制。

只要运行在同源的父页面中，workers 可以依次生成新的 workers; 

Web Worker 分为**专用 Worker** 和**共享 Worker**

Web Workers :

- Mainly used to run heavy and complicated scripts.
- Can be installed in the script by using,

Service Workers :

- Handles network requests and Their responses, more like a proxy.
- Mainly used for creating offline operations in apps or web pages.
- A service worker has to be registered to avail of it.

## 垃圾回收机制
1. 标记清除

    这是 JS 中最常用的垃圾回收方式。当变量进入上下文，比如函数内部声明一个变量时，这个变量会被加上存在于上下文中的标记。而在上下文中的变量，逻辑上讲，永远不应该释放它们的内存，因为只要上下文中的代码在运行，就有可能用到它们。当变量离开上下文时，也会被加上离开上下文的标记。

    垃圾回收程序运行的时候，会标记内存中存储的所有变量。然后它会将所有在上下文中的变量，以及被在上下文中的变量引用的变量的标记去掉。在此之后再被加上标记的变量就是待删除的了。随后垃圾回收程序做一次**内存清理**，销毁带标记的所有值并回收它们的内存。
2. 引用计数

    思路是对每个值都记录它被引用的次数。声明变量并给它赋一个引用值时，这个值的引用数为 1。如果同一个值又被赋值给另一个变量，那么引用数加 1.当一个值的引用数为 0 时，就说明没办法再访问到这个值了，因此可以安全地回收其内存了。垃圾回收程序下次运行的时候就会释放引用数为 0 的值的内存。
3. 哪些情况会引起内存泄漏？

    虽然 JavaScript 会自动垃圾收集，但是如果我们的代码写法不当，会让变量一直处于“进入环境”的状态，无法被回收。内存泄漏的几种常见情况：
    1. 意外的全局变量
        - 没有声明的变量会变成一个全局变量，页面关闭前不会被释放
        - 函数中用 `this` 给变量赋值，全局上下文中执行该函数，`this` 将会指向全局对象
    2. 被遗忘的计时器 - 不需要计时器时应及时清除
    3. 闭包
    4. 没有清理的 DOM 元素引用
4. 识别方法

    chrome 中的 performance 可以查看内存情况，途中 Heap 对应的部分就可以看到内存在周期性的回落也可以看到垃圾回收的周期，如果垃圾回收之后的最低值 min 在不断上涨，那么肯定是有较为严重的内存泄漏问题。
    
5. 垃圾回收场景优化
   1. 数组优化，清空数组可以将数组长度设为 0, 避免分配新的数组对象
   2. 对象尽量复用，不用的对象尽可能设置为 null

## Babel 的原理

Babel 能够转译 ECMAScript 2015+ 的代码，使它在旧的浏览器或者环境中能够运行。

Babel 的工作过程：
大多数编译器的工作过程可以分为三个部分
1. **Parse(解析)**: 将源代码转换成更加抽象的表示方法，例如 AST；
2. **Transform(转换)**: 对 AST 做一些特殊处理，让它符合编译器的期望；
3. **Generate(代码生成)**: 将第二步经过转换后的 AST 生成新的代码；

### Parse（解析）
一般来说，Parse 阶段可以细分为两个阶段：**词法分析**和**语法分析**。

#### 词法分析
词法分析阶段可以看成时对代码进行分词，它接收一段源代码，然后执行一段 tokenize 函数，把代码分割成被称为 **Tokens** 的东西。**Tokens**是一个数组，由一些代码的碎片组成，比如数字、标点符号、运算符号等等。
通过 http://esprima.org/demo/parse.html 生成的。

#### 语法分析
**词法分析**之后，代码就已经变成了一个 Tokens 数组了，**语法分析**负责把 Tokens 转化为上面提到过的 AST。

### Transform（转换）
这一步做的事情也很清晰，就是操作 AST, 例如箭头函数是 ES5 不支持的语法，所以 Babel 得把它转换成普通函数，一层层遍历下，找到了 ArrowFunctionExpression 节点，这时候就需要把它替换成 FunctionDeclaration 节点。

这一步是 [babel-traverse](https://github.com/babel/babel/tree/master/packages/babel-traverse) 在做。

### Generate（代码生成）
经过上面两个阶段，需要转译的代码已经转换，生成新的 AST 了，最后一个阶段理所应当就是根据这个 AST 来输出代码。
Babel 是通过 [babel-generator](https://github.com/babel/babel/tree/master/packages/babel-generator) 来完成的。

经过这三个阶段，代码就被 Babel 转译成功了。

## ES6 新增特性
1. 声明关键字：let const import class
2. Proxy & Reflect
3. Map / WeakMap / Set / WeakSet
4. ES Module (import & export)
5. Promise

## js 中一个数字占多少字节

只针对数字的话，js 中数字是 64 位浮点数表示数字，1byte(字节) = 8bit(位)，所以是 8byte。
一般中文占2个字节，英文占1个字节。

## js 基本数据类型：Undefined, Null, Boolean, Number, String, Symbol(new in es6)。引用类型：Object, Array, Date, RegExp, Function

## promise 和 async await 的区别

它们都是异步编程的一种解决方案，promise 的出现解决了传统 callback 函数回调地狱的问题，支持链式调用，promise 有三种状态，一旦函数执行 promise 状态进入 fulfilled 或 Rejected 状态就无法改变，遇到复杂的业务逻辑 promise 显然不是那么方便，需要不停的执行 then, 代码也不美观。而 async await 是基于 promise 实现的，它是基于 Generator 函数的语法糖，它拥有内置执行器，返回的是一个 promise 对象，可以使异步代码看起来像同步代码一样，更方便阅读和理解，解决了 promise 的调用链

## 同步与异步

- 同步：
	- 指在**主线程**上排队执行的任务，只有前一个任务执行完毕，才能继续执行下一个任务
	- 也就是调用一旦开始，必须等待返回结果，才能继续往后执行。程序的执行顺序和任务排列顺序是一致的。
- 异步：
	- 异步任务是指不进入主线程，而进入**任务队列**的任务，只有任务队列通知主线程，某个异步任务可以执行了，该任务才会进入主线程。
	- 每个任务有一个或多个回调函数。前一个任务结束后，执行回调函数，后一个任务不等钱一个任务结束就执行
	- 程序的执行顺序和任务的排列顺序是不一致的，异步的

实现异步的方法：回调函数、事件监听、发布订阅、Promise/A+、生成器、async/await

## 面向对象的三个特征，分别说一下什么意思

- **封装**：就是将客观事物抽象为逻辑实体，**实体的属性和功能相结合**，形成一个有机的整体。并**对实体的属性和功能实现进行访问控制**，向信任的实体开放，对不信任的实体隐藏。**通过开放的外部接口即可访问**，无需知道功能如何实现。也就是说，封装主要有以下目的：
  - 可隐藏实体实现的细节
  - 提高安全性，设定访问控制，只允许具有特定权限的使用者调用。
  - 简化编程，调用方无需知道功能是怎么实现的，即可调用。
- **继承**：在继承机制下形成有层级的类，**使得低层级的类可以延用高层级类的特征和方法**。继承的实现方式有两种：实现继承、接口继承。
  - **实现继承**：直接使用基类公开的属性和方法，无需额外编码。
  - **接口继承**：仅使用接口公开的属性和方法名称，速妖子类实现。

    也就是说，继承有以下目的：
  - 复用代码，减少类的冗余代码，减少开发工作量。
  - 使得类与类之间产生关系，为多态的实现打下基础
- **多态**：是指一个类的**同名方法，在不同情况下的实现细节不同**。多态机制实现**不同的内部实现结构共用同一个外部接口**。也就是说，多态有以下目的：
  - 一个外部接口可被多个同类使用
  - 不同对象调用同个方法，可有不同实现

    多态实现的三个必要条件是：继承、重写（子类继承父类后，对继承的方法重新定义）、父类应用指向子类对象。所以，**多态的实现是基于继承**的。
   
## typeof 的值
- "undefined"
- "boolean"
- "number", 
- "bigint"
- "string"
- "symbol"
- 宿主对象（由 JS 环境提供）取决于具体实现
- "function"
- "object"


# HTML
## HTML 语义化
语义化的含义就是正确的标签做正确的事情，HTML 语义化就是让页面的内容结构化，便于浏览器、搜索引擎解析；在没有样式 CSS 的情况下也以一种文档格式显示，并且是容易阅读的。搜索引擎的爬虫依赖于标记来确定上下文和各个关键词的权重，利于 `SEO` 。使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。


# CSS
## 盒模型
盒模型的属性可以分成三组：

- 边框(border)
- 内边距(padding)
- 外边距(margin)
盒模型分为两种：IE 盒模型（border-box）和 W3C 标准盒模型（content-box）。
他们的区别是：
- W3C 标准盒模型的 width，height 属性只包含内容（content），不包含 border 和 padding
- IE 盒模型的 width、height 属性包含内容(content)、padding 和 border

## 伪类和伪元素的区别
css 引入伪类和伪元素概念是为了格式化文档树以外的信息。也就是说，伪类和伪元素用来修饰**不在文档树中的部分**。
伪类分两种：
- **UI 伪类**会在 HTML 元素处于某个**状态**时，为该元素应用 CSS 样式
- **结构化伪类**会在标记种存在某种结构上的关系（如某个元素是一组元素种的第一个或最后一个），为相应元素应用 CSS 样式

伪元素用于创建一些不在文档树种的元素，并为其添加样式。它们允许我们为元素的某些部分设置样式。例如通过`::before` 在一个元素前增加一些文本，并为这些文本添加样式。虽然可以看到这些文本，但是实际上不在文档树中。

有时你会发现`伪元素`使用了两个冒号`（::）`而不是一个冒号`（:）`。这是CSS3的一部分，并尝试区分伪类和伪元素。大多数浏览器都支持这两个值。按照规则应该使用`（::）`而不是`（:）`，从而区分伪类和伪元素。但是，由于在旧版本的W3C规范并未对此进行特别区分，因此目前绝大多数的浏览器都支持使用这两种方式表示伪元素。

## 简述 px, em, rem, vh 的含义和应用场景
1. px: 绝对单位，页面按精确像素展示。一般用在设置字体大小时的单位
2. em: 相对单位，基准点为父节点字体大小，如果自身定义了 `font-size`，按自身来计算。**一般用在设置元素的边距和宽高时使用，以此来根据字体大小自适应。**
3. rem: 相对单位，可以理解为 "root em"，相对根节点 html 的字体大小来计算
4. vh: 视口单位，根据浏览器窗口的大小的单位，不受显示器分辨率的影响。1vh = 可视窗口的高度的百分之一。**一般用于实现自适应**

## css 中 position 的取值有哪些？
1. static: 静态定位。position 属性的默认属性值。static 元素声明的 left 和 top 等无效
2. relative：相对定位。可以用 left、top、right 和 bottom 属性改变它的位置，相对它原来在文档流中的位置
3. absolute：绝对定位。绝对定位会让元素**脱离文档流**，left、top、right 和 bottom 属性时相对于其**定位上下文**的（默认为 body）。由于绝对定位元素的定位上下文是 body，所以在页面滚动时，为了维护与 body 元素的相对位置关系，他也会相应地移动。改变上下文只需将该元素的祖先元素的 position 设为 relative 即可。
4. fixed 固定定位。固定定位也会让元素**脱离文档流**。固定定位元素的**定位上下文是视口**（浏览器窗口或手持设备的屏幕），因此它不会随页面滚动而滚动。
5. sticky 粘性定位。基于用户的滚动位置来定位。粘性定位的元素依赖于用户的滚动，在 `relative` 和 `fixed` 定位之间切换。它的行为就像 `relative`，而当页面滚动超出目标区域时，它的表现就像 `fixed`，它会固定在目标位置。只有指定了 top/right/bottom/left 之一，才能使粘性定位生效，否则其行为与相对定位相同。


## display:none 和 visibility:hidden 隐藏的区别
- `display: none` 元素及所有包含在其中的元素，都不会在页面中显示。它们不再占据空间，就像相关标记不存在一样。改变该属性会引起**回流**。
- `visibility: hidden` 元素只是隐藏了，但是在文档流中还占位。改变该元素不会引起回流。

## CSS中怎么实现居中？
### 水平居中
1. 行内元素
    ```css
    .center { text-align: center; }
    ```
2. 单个块级元素
   1. inline-block & text-align 
        单个多个块级元素都能用'
        
        ```scss
        .outer {
            text-align: center;
            .inner { display: inline-block; }
        }
        ```
        
    2. flex & justify-content 单个、多个块级元素、浮动元素都能使用
    3. width & margin **定宽** + 水平 auto
    
        ```css
        .inner {
            width: 200px;
            margin: 0 auto;
        }
        ```
        
    4. absolute & transfrom

        ```scss
        .outer {
            position: relative;
            .inner {
                position: absolute;
                left: 50%;
                transform: translateX(-50%);
            }
        }
        ```
        
    5. flex & margin
    
        ```scss
        .outer {
            display: flex;
            .inner {
                margin: 0 auto;
            }
        }
        ```

    6. table & margin

        ```scss
        .inner {
            display: table;
            margin: 0 auto;
        }
        ```
        
3. 多块级元素
   1. inline-block & text-align
   2. flex & justify-content
4. 浮动元素水平居中
   1. 对于定宽的浮动元素，通过子元素设置 relative+负margin
   2. 对于不定宽的浮动元素，父子元素都设置 relative
   
        ```css
        .box {
            float: left; // 清除浮动
            position: relative;
            left: 50%;
        }
        .inner {
            float: left;
            position: relative;
            right: 50%;
        }
        ```
        
   3. flex & justify-content
5. 绝对定位元素水平居中
    子元素绝对定位，left 和 top 为 0，设置 margin: 0 auto 来实现
    
### 垂直居中
1. 单行内联元素
    line-height 和 height 值设为相等

2. 多行内联元素
    1. flex & flex-direction: column; & justify-center
    2. table 布局
    
        ```scss
        .p { display: table; }
        .child {
            display: table-cell;
            vertical-align: middle;
        }
        ```
        
3. 块级元素垂直居中
   1. absolute + 负 margin （已知高度）
   2. absolute + transform
   3. flex + align-items
   4. table-cell + vertical-align: middle;

### 水平垂直居中
1. 绝对定位 + 负 margin (已知宽高)

    ```scss
    .p { position: relative }
    .center {
        position: absolute;
        top: 50%;
        left: 50%;
        margin: -50px 0 0 -50px;
    }
    ```
    
2. 绝对定位 + margin:auto; （已知宽高）

    ```scss
    .p { position: relative; }
    .center {
        position: absolute;
        top: 0;
        left: 0;
        bottom: 0;
        right: 0;
        margin: auto;
    }
    ```
    
3. 绝对定位 + transform （未知宽高）
4. flex & justify-content & align-items
5. flex/grid & margin: auto

## 为什么css选择器从右向左解析？
无效匹配次数更少，从而匹配快、性能更优，所以目前主流的浏览器基本采取 right-to-left 的方式读取css规则。

## 层叠上下文(stacking context)
层叠上下文就是对 HTML 元素的一个三维构想

### 文档中的层叠上下文由满足以下任意一个条件的元素形成：
- 文档根元素
- position 值为 absolute 或 relative 且 z-index 值部位 auto 的元素
- position 为 fixed 或 sticky 的元素
- flex/grid 容器的子元素，且 z-index 不为 auto
- opacity 为 1 的元素
- 以下任意属性值不为 none 的元素
  - transform
  - filter
  - backdrop-filter
  - clip-path
  - mask / mask-image / mask-border
### 层叠上下文规律
明确指定了 `z-index` 的值（不是 auto）的定位元素才会生成一个层叠上下文，在这个层叠上下文中，内部元素层级都在它之上，哪怕是负数。
如果是一个没有指定 `z-index` 的定位元素，那么虽然它不能形成一个层叠上下文，但是比较层级时，和 `z-index: 0` 是一样的。
1. 首先看块级元素，我们能看到他，就是因为它在层叠上下文根元素之上
2. 然后是浮动元素和文字，浮动本身是为了实现环绕效果的，所以浮动元素和文字是同一级的，这样才不会遮挡。
3. 然后是定位元素，不指定 `z-index` 时，是会在浮动元素之上的，在层级关系中相当于 0, 可以继续推出：`z-index>0`的会在 `z-index=0` 之上
4. 唯一要注意的是 `z-index<0`, 它的层级关系是在块级元素之下，形成层叠上下文的元素之上的

其中，当多个层叠等级相同的元素重叠时，按照出现顺序决定堆叠上下关系，后出现的在上。

### 总结
层叠上下文和 `z-index` 两个概念时分不开的。一个层叠上下文是由许多拥有 `z-index` 属性元素形成的平面构成的；有 `z-index` 属性的元素又会形成一个子层叠上下文。当然，这里的 `z-index` 必须是被有效设置的，在以前是指被定位的元素 `position` 为 `absolute/relative` 等，现在它还可以是 `flex` 的子元素。

## BFC
BFC 全称叫块级格式上下文，是块级盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。简单来说，BFC 是一个完全独立的空间（布局环境），让空间里的子元素不会影响到外面的布局。
BFC 影响布局，通常我们会为定位和清除浮动创建新的 BFC 和不是更改布局，因为它将：

- 阻止**外边距重叠**
- 包含**内部浮动**: 让浮动内容和周围的内容等高。
- 排除**外部浮动**: 正常文档流中建立的 BFC 不得与元素本身所在的块格式化上下文中的任何浮动的外边距重叠。

下列方式会创建 BFC：

- 根元素
- 浮动元素（float 值不为 none）
- position: absolute | fixed
- display: inline-block | table-cell(表格单元格默认值) | table-caption(表格标题) | flow-root.
- overflow: 不为 visible | clip 的块元素
- flex | inline-flex | grid | inline-grid 元素的直接子元素（即弹性元素和网格元素） 
- column-spam: all

## 叠加外边距
在CSS中，两个或多个毗邻的普通流中的盒子（可能是**父子元素**，也可能是**兄弟元素**）在垂直方向上的外边距会发生叠加。

- 普通流：只要不是 float、absolutely positioned 和 root element 就是普通流（in-flow）。
- 产生叠加外边距的条件是：
  - 都属于普通流的块级盒子且在到相同的块级格式上下文中
  - 都没有被 padding、border、clear 和 line box 分隔开
  - 都属于垂直毗邻盒子边缘：
  - 盒子的 top margin 和它的第一个普通流**子元素**的 top margin;
  - 盒子的 bottom margin 和它下一个普通流**兄弟**的 top margin;
  - 盒子的 bottom margin 和它**父元素**的 bottom margin
  - 盒子的 top margin 和 bottom margin，且没有创建一个新的块级格式上下文(BFC)，且有被计算为 0 的 min-height，被计算为 0 或 auto 的 height，且没有普通流子元素
 
## Layout 布局
### 两栏布局
1. float + overflow: hidden

    ```scss
    .outer {
        overflow: hidden; // 清除浮动
        .left {
            width: 200px;
            float: left;
        }
        .right {
            overflow: hidden; // 创建 BFC
        }
    }
    ```
    
2. flex 布局: 左边定宽，右边 `flex: 1;`
3. grid 布局：基于网格的二维布局，目的是用来优化用户界面设计。

    ```scss
    .outer {
        display: grid;
        grid-template-columns: auto 1fr;
        grid-gap: 20px;
    }
    ```

### 三栏布局
1. margin 负值法：左右两栏均左浮动，左右两栏用负 margin 值。中间栏被宽度为 100% 的浮动元素包起来。
2. 浮动布局
  这种布局方式，DOM 结构必须先写浮动元素，最后写中间元素，否则右浮动会掉到下一行
  
  ```html
      <style>
          .left {
              float: left;
              width: 300px;
          }
          .right {
              float: right;
              width: 300px;
          }
          .center {}
      </style>
  ```
  
3. 绝对定位法：左右两栏采用绝对定位，分别固定于页面的左右两侧，中间的主体栏用左右 margin 值撑开距离。
4. Flexbox 布局 - 左右定宽，中间 `flex: 1;`

  flexbox 是 css3 里新出的，目前移动端的布局也都是使用 flexbox。缺点是 IE10 才开始支持的
  
    ```html
        <style>
            .container {
                display: flex;
            }
            .left {
                width: 300px;
            }
            .right {
                width: 300px;
            }
            .center {
                flex: 1
            }
        </style>
        <article class="container">
            <div class="left"></div>
            <div class="center"></div>
            <div class="right"></div>
        </article>
    ```
    
5. 网格布局
    
    css grid 是创建网格布局最强大和最简单的工具。就像表格一样，网格布局可以让 web 设计师根据元素按列或行对其排列，但他和表格不同，网格布局没有内容结构，从而使各种布局不可能与表格一样。
    但网格布局兼容性不好。IE10+ 支持，而且也仅支持部分属性
    
    ```html
        <style>
            .layout {
                display: grid;
                width: 100%;
                grid-template-columns: 300px auto 300px;
                grid-template-rows: 150px;
            }
            .left{}
            .center{}
            .right{}
        </style>
    ```
    
6. 表格布局

## 响应式布局

描述响应式界面最著名的一句话就是 "Content is like water", 如果将屏幕看作容器，那么内容就像水一样。

**实现方式**
响应式设计的基本原理是通过媒体查询检测不同的设备屏幕尺寸做处理，为了处理移动端，页面头部必须有 meta 声明 viewport, 约束视口

```html
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
```

属性对应如下：

- `width=divice-width`: 是自适应手机屏幕的尺寸宽度
- `maximum-scale`: 最大缩放比例
- `initial-scale`: 初始缩放比例
- `user-scalable`: 是否允许用户的缩放页面

实现响应式布局的方式如下：
- 媒体查询
- 百分比布局 - 弹性盒布局
- vw/vh
- em/rem
- 弹性盒
- 网格布局

1. 媒体查询

    媒体查询是 css3 规范中的一部分，媒体查询提供了简单的判断方法，允许开发者根据不同的设备特征应用不同的样式。响应式布局中，常用的设备特征有：
    
    - `min-width`: 视口宽度最小值
    - `max-width`: 视口宽度最大值
    - `orientation`: 当前设备方向

    选择 `min-width` 和 `max-width` 取值的过程，成为设备断点选择，它可能取决于产品设计本身，下面是百度 Web 生态团队总结的一套比较具有代表性的设备断点：
    
    ```css 
        /* 很小的设备，小于 600px */
        @media only screen and (max-width: 600px) {}
        /* 比较小的设备（竖屏的平板，屏幕较大的手机，大于 600px） */
        @media only screen and (min-width: 600px) {}
        /* 中型大小设备（横屏的平板，大于 768px */
        @media only screen and (min-width: 768px) {}
        /* 大型设备，电脑等 */
        @media only screen and (min-width: 992px) {}
        /* 超大型设备，大尺寸电脑屏幕 */
        @media only screen and (min-width: 1200px) {}
    ```
    
2. 百分比布局

    百分比布局也叫做流式布局、弹性盒布局

    当浏览器的宽度或者高度发生变化时，通过百分比单位，可以使得浏览器中的组件的宽和高随着浏览器的变化而变化，从而实现响应式的效果。

    height、width 属性的百分比依托于父标签的宽高，但是其他盒子属性则不完全依赖父元素：
    
    - 子元素的 top/left/bottom/right 如果设置百分比，则相对于非 static 定位的父元素的高度/宽度
    - 子元素的 padding/margin 如果设置百分比，不论是垂直方向或者是水平方向，都相对于直接父元素的 width
    - 不能用百分比写 border 的宽度
    - border-radius 不同，如果设置为百分比，则是相对于自身的宽度

    如果每个属性都是用百分比，会造成布局的复杂度，所以不建议使用百分比来实现响应式。
    
3. vw/vh

    它们是相对于视口的
    
    - vw, viewport width, 视口宽度, 所以 1vw = 1% 视口宽度
    - vh, viewport height, 视口高度, 所以 1vh = 1% 视口高度
4. rem 响应式布局
    
    rem 响应式布局思想
    1. 一般不给元素设置具体的宽度，但是对于一些小图标可以设定具体宽高度
    2. 高度值可以设置固定值，设计稿多大，就严格写多大；
    3. 所有设置的固定值都用 REM 做单位（首先在 HTML 中设置一个基准值：PX 和 REM 的对应比例，然后在效果图上获取 PX 值，布局的时候转化为 REM）
    4. JS 获取真实屏幕的宽度，让其除以设计稿的宽度，算出比例，把之前的基准值按照比例进行重新设定，这样项目就可以在移动端自适应了。

    rem 与 em 的区别
    
    - em: 相对于元素自身的 `font-size`, 更适合模块化的页面元素，比如 Web Components
    - rem: 相对于根元素 html 的 `font-size` 属性，因此 rem 更加方便。可以利用前面提到的媒体查询，针对不同设备分辨率改变 `font-size` 的值

    ```css
        @media screen and (min-width: 320px) {
            html { font-size: 14px; }
        }
        @media screen and (min-width: 360px) {
            html { font-size: 16px; }
        }
        @media screen and (min-width: 400px) {
            html { font-size: 18px; }
        }
    ```
    
5. 响应式文字和图片
    - 文字：基本字体一般不小于 16px, 行高大于 1.2em（感觉可以不用）
    - 图片
		1. 确保图片内容不会超出 viewport, 设置元素的最大宽度进行限制(`max-width: 100%;`)。
		2. 图片质量支持响应式
		
		    这是一种支持优雅降级的方案，现代浏览器已经支持 `srcset` 和 `sizes` 属性，对于兼容性不好的浏览器，会继续使用默认 `src` 属性中的图片，所以我们可以放心大胆的使用。
		    
		    - `srcset` 支持定义几组图片和对应的尺寸
		    - `sizes` 支持一组媒体查询条件

## 说下对弹性布局(`flex`)的理解？
就是 flex 布局，flex 父容器中的子元素通过 `flex-grow`，`flex-shink`，`flex-basis` 属性可以随着父容器宽度大小自适应，也就是能够实现兼容不同分辨率屏幕

### 弹性盒子中 flex: 1 和 flex: 0 1 auto 是什么意思
`flex: 1` 是 `flex: 1 1 auto;` 的缩写

三个参数分别是

- `flex-grow` 增长比例，默认为0，即如果存在剩余空间，也不放大。（当子项合计宽度小于容器宽度，需要根据每个子项设置的此属性比例对剩下的长度进行分配）
- `flex-shrink` 回缩比例，默认为1，即如果空间不足，该项目将缩小。（子项合计宽度大于容器宽度，需要根据每个子项设置的此属性比例多出的长度进行分配）
- `flex-basis` 定义了再分配多余空间之前，占据的主轴空间。`auto` 即本身的大小


### 父容器 flex 布局，有三个子元素，设置 `flex: 0 0 auto;`显示效果什么样？
不显示，子元素宽度都为0

## 清除浮动
1. 为父元素添加 `overflow: hidden;`

   这种方案让父容器形成 BFC，而 BFC 可以包含浮动，通常用来解决父元素高度塌陷的问题。
   
   但这个办法有个缺陷：如果有内容出了盒子，用这种方法就会把多的部分裁切掉。
   
2. 同时浮动父元素
3. 添加非浮动的清除元素
  1. 就是在父元素的最后一个子元素后添加一个子元素，并给他应用 `clear` 属性，该元素必须是一个块级元素，否则无法撑起父级元素高度由于没有默认的样式，不会引入多余空间
  2. 给父元素添加一个 `clearfix` 的类，然后给这个类添加一个 `:after` 伪元素。

       ```css
           .wrap.clearfix:after {
               content: ".";
               height: 0;
               display:block;
               clear:both;
               line-height: 0;
               visibility: hidden; // 渲染它，但是不显示出来
           }
       ```
       
4. br标签清浮动: br 标签存在一个属性: clear. 这个属性就是能够清浮动的理器。在 br 标签中设置属性 clear 为 all. 即能清除掉浮动。

## css 隐藏 dom 的几种方法
1. display: none; 脱标
2. visibility: hidden; 不脱标
3. opacity: 0; 不脱标
4. position: absolute; 脱标
5. cli-path:polygon(0px 0px, 0px 0px, 0px 0px, 0px 0px) 不脱标
6. position: absolute; clip:rect(0px 0px 0px 0px) 配合 通过裁剪绝对定位盒子 脱标

## css 自定义颜色的几种方法
1. RGB(百分比)
2. RGBA(数字)
3. 十六进制
4. 关键字

## 回流和重绘
### 什么是回流和重绘
#### 回流（Reflow）
当渲染树render tree中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。这就称为回流(reflow)。每个页面至少需要一次回流，就是在页面第一次加载的时候，这时候是一定会发生回流的，因为要构建render tree。在回流的时候，浏览器会使渲染树中受到影响的部分失效，并重新构造这部分渲染树，完成回流后，浏览器会重新绘制受影响的部分到屏幕中，该过程称为重绘。

简单来说，回流就是计算元素在设备内的确切位置和大小并且重新绘制

回流的代价要远大于重绘。并且回流必然会造成重绘，但重绘不一定会造成回流。

#### 重绘（Repaint）
当渲染树render tree中的一些元素需要更新样式，但这些样式属性只是改变元素的外观，风格，而不会影响布局的，比如background-color。则就叫称为重绘(repaint)。

简单来说，重绘就是将渲染树节点转换为屏幕上的实际像素，不涉及重新布局阶段的位置与大小计算

### 如何减少回流和重绘
会导致回流的操作：
- 页面首次渲染（无法避免且开销最大的一次）
- 浏览器窗口大小发生改变（resize事件）
- 元素尺寸或位置发生改变（边距、宽高、边框等）
- 元素内容变化（文字数量或图片大小等等）
- 元素字体大小变化（font-size）
- 添加或者删除可见的DOM元素
- 激活CSS伪类（例如：:hover）
- 查询某些属性或调用某些方法


- CSS
  1. 避免使用 table 布局，一个很小的改动都可能造成整个 table 的回流
  2. CSS选择符从右往左匹配查找，避免节点层级过多
  3. 避免设置多层内联样式
  4. `visibility` 代替 `display:none`,前者只引起重绘，后者引起回流；
  5. 将动画效果应用到 `position` 属性为 `absolute` 或 `fixed` 元素上，使它**脱离文档流**，否则会引起父元素及后续元素频繁回流。
  6. 通过 `transfrom` 和 `opacity` 生成合成层，这些属性的修改会直接进入合成阶段；（减少合成层占用的内存，合成层的最大问题就是占用内存较多，而内存的占用和元素尺寸是成正比的，如果要实现一个 100 × 100 的元素，可以给宽高设置为 10px，再使用 `transfrom:scale(10)` 放大十倍，这样占用的内存只有设置的 `1/100`。
- JavaScript - 尽量避免用 JS 操作和访问 DOM
  1. 合并对 DOM 样式的修改，预先定义好 class，直接修改 `className`；
  2. DOM 离线处理
    1. 也可以先将元素设置为 `display:none;`，操作结束后再把它显示出来。
    2. 创建一个 `documentFragment`，在它上面应用所有 DOM 操作，最后把它添加到文档中。
    3. 克隆节点，修改完再替换原始节点
  3. 避免频繁读取会引发回流/重绘的属性，有必要的话就将值用一个变量存起来

## 怎么让chrome支持小于12px 的文字
设置-webkit-text-size-adjust:none;（最新chrome已不支持） 设置-webkit-transform:scale(0.8);

## offsetHeight, clientHeight, scrollHeight, height的区别

## 手写 CSS
### 用 CSS 实现一个三角形
### 用 CSS 实现一个正方形

	```css
	    .square {
	        width: 50%;
	        height: 0;
	        padding-bottom: 50%;
	        overflow: visible;
	        background-color: black;
	    }
	```
	
### 在一个div里面，有三个块级元素，分别为 1 | 3 | 2，现在要把它们排成一行，并且顺序为123，css 怎么做？

    ```html
    <style lang="scss">
        .in_3 {
            float: right;
        }
        .in_1, .in_2 {  // method 1
            display: inline-block;
        }
        // method 2
        .outer {
            overflow: hidden;
        }
        .in_1, .in_2 { 
            float: left;
        }
        .outer { // method 3
            display: flex;
        }
    </style>
    <div class="outer">
        <div class="in_1">1</div>
        <div class="in_3">3</div>
        <div class="in_2">2</div>
    </div>
    ```
    
### 画一条 0.5px 的线
1. height: 1px + transform: scaleY(0.5) + transform-origin: 50% 100%
2. linear-gradient(0deg, #fff, #000) 线性渐变一个 px 是一个颜色，在高清屏两个 px 渲染一个 px，所以第一个 px 是#fff, 第二个 px 是 #000，达到只画了一半的目的
3. height: 1px + box-shadow 的第二个参数设置为 0.5px, 表示阴影垂直方向偏移 0.5px

	`<meta name="viewport" content="initial-scale=1.0,maximum-scale=1.0,user-scalable=no" />`

# Vue 面经
## vue 实现组件间通信的方法有哪些？ II
- 父传子通过 props 传值
- 子传父通过 $emit 
- 祖孙之间传值用 provide/inject
- EventBus **中央事件总线机制**。挂在一个空的 Vue 对象，通信发送方在这个对象上发布事件，接收方则订阅这个事件。
- Vuex

## vue 中父子组件生命周期执行顺序？ II
1. 加载渲染过程

    Parent.beforeCreate -> Parent.created -> Parent.beforeMount ->
    Child.beforeCreate -> Child.created -> Child.beforeMount -> Child.mounted -> Parent.mounted

2. 子组件更新过程

    Parent.beforeUpdate -> Child.beforeUpdate -> Child.updated -> Parent.updated

3. 父组件更新过程

    Parent.beforeUpdate -> Parent.updated

4. 销毁过程

    Parent.beforeDestory -> Child.beforeDestory -> Child.destoryed -> Parent.destoryed

## Vuex 的实现原理了解过吗？你会怎么实现？II
首先，围绕这个生态圈，其各模块在核心流程中的主要功能：

- Vue components: 
Vue 组件。HTML页面上，负责接收用户操作等交互行为，执行 dispatch 方法触发对应的 action 进行回应。
- dispatch: **操作触发方法**，是唯一能执行 action 的方法。
- actions: **操作处理模块**，负责处理 Vue Components 接收到的所有交互行为，包括同步/异步操作，支持多个同名方法，按照注册的先后顺序依次触发。可以在此处发起向后台 API 的请求，包括触发其他 action 一起提交 mutation 的操作。该模块提供了 promise 的封装，以支持 action 的**链式触发**。
在内部用一个对象存放 actions ，action name作为 key ，action 方法作为值，在 dispatch 方法中通过这个对象找到对应的 action，如果只有一个 action，直接执行；否则用 Promise.all() 执行所有 action 方法
- commit: **状态改变的提交方法**。对 mutation 进行提交，是唯一能执行 mutation 的方法。
- mutations: **状态改变方法**，是 Vuex 修改 state 的唯一方法，其他修改方式在**严格模式**下会报错。该方法只能进行同步操作，且方法名只能全局唯一。操作中会有一些 hook 暴露出来，以进行 state 的监听等。
mutations 与 actions 一样，需要在内部维护一个 mutations 对象存放，mutation name 作为 key, mutation 本身作为 value, 在 commit 方法内通过这个 mutations 对象找到找到对应的 mutation 方法。
- state: **全局状态管理容器对象**，集中存储整个 app 的共享数据，全局唯一，以进行统一的状态管理。
利用 Vue 的细粒度数据响应机制来进行高效的状态更新。
- getter: state 对象的读取方法，Vue components 通过 getter 读取全局 state 对象。
Vuex 中使用了 Vue 的 computed 对 getter 方法进行了封装，所以 getter 是具有缓存功能的。
- module: Vuex 的模块，通过 store 中的 makeLocalContext 方法为每一个模块创建一个上下文对象，通过声明 namespace 区分不同的上下文，上下文对象中声明的所有属性都会带有命名空间前缀，当我们在 Vue 组件中使用了命名空间分发操作(dispatch action)时，store 对象会根据命名空间拼接前缀，最后合成一个 key，在 actions 对象中找到匹配的 action 并执行；如果是在上下文对象中执行操作的话，默认拿到的都是当前上下文中的属性（state, action, mutation, getter)，如果要访问其他上下文的属性，只能通过 root state 匹配命名空间的方式访问。

### 怎么区分 state 是否是外部修改的？

state 是利用 Vue 的数据响应机制实现的，所以我们可以给 state 注册数据更新的事件回调，然后维护一个**标识符 _committing**
- 当 commit 在提交 mutation 更新 state 前，把标识符置为 true。
- 提交了 state 的更新后，触发事件回调函数，（严格模式下）在事件回调中检查标识符是否为 true，如果是，说明是合法的更新；否则，是来自外部的修改，抛出错误
- commit 在提交 mutation 之后，还原标识符

内部还有一个 replaceState 方法也可以，替换 store 根状态，一般用于状态合并或 time-travel 调试

### 使用 Vuex 只需执行 Vue.use(Vuex)，并在Vue的配置中传入一个store对象的实例，store是如何实现注入的？ III

Vue.use(Vuex) 方法执行的是插件中的 install 方法（在这之前 Vue 会检查该插件是否已经 install），它实现了 Vue 实例对象的 init 方法封装和注入，使传入的 store 对象被混入到了 Vue 的上下文环境中的 `$store` 中(`app.config.globalProperties.$store`)。因此在 Vue components 的任意地方都可以通过 `this.$store` 访问到该 state。

此方法必须在创建 Vue 实例之前调用，因为在初始化实例的过程中才会调用 Vue 的 `_init` 方法，如果在这之前调用，`_init`方法将不会对这个插件有效，进而插件中想要挂载的一些全局属性就不会有效。

tips: Vue3 中是通过 provide api 注入 store 对象的

### state内部是如何实现支持模块配置和模块嵌套的？ II
    
在 store 执行构造方法的时候，会执行 makeLocalContext 方法为每个模块创建 local context，根据 namespace 进行匹配，当在模块内执行一些操作，比如说 dispatch 一个 action 的时候，默认拿到的都是当前模块的 local state，如果要访问其他模块的的 state，只能从 rootState 按照 path 路径匹配到其他模块的 namespace 命名空间，在他们的 local context 下获取 state。

### 在执行 dispatch 触发 action（commit同理）的时候，只需传入（type, payload），action执行函数中第一个参数store从哪里获取的？ II

store 初始化的时候，会注册所有的 actions、mutations 和 getters，注册过程中会进行封装，使用 call 方法使他们能够在全局 state 上下文中执行，并且其第一个参数就是当前命名空间的 store 对象，(所以能够访问包括 dispatch, commit, getter, state, rootState 等属性)

### 调试时的“时空穿梭(time-travel)”功能是如何实现的？ II

Vuex 中植入了插件 devtools, devtools 订阅了 state 的 mutation 事件，每次提交 mutation 之后，都会调用 devtools 的回调，并且会传入 mutation 和当前的 state，在 devtools 的回调中记录每次的 mutation 、新的 state 以及时间，时空穿梭的功能就是把当前的 state 替换成记录中某一时刻的 state。
        

## 为什么 Vuex 中的 mutation 不能做异步操作？I
答：其实这只是人为的规定不能在 mutation 中进行异步操作。
在 mutation 中混入异步调用会导致程序难以调试，因为无法预测哪个回调会先执行，state 什么时候会改变。
而同步的意义在于这样每一个 mutation 执行完成后都可以对应到一个新的状态（和 reducer 一样），这样 devtools 就可以打个 snapshot 存下来，然后就可以随便 time-travel 了。
   
## Vuex 和 Redux 的设计思想 II
从两者的异同点来讲的话：

- 相同点：
  - 两者都是全局状态管理工具
  - 都倾向于暴露一个方法去改变状态，而不是直接修改；Redux 通过 `dispatch(action)` 执行 `reducer` 对应的 `action` ，然后生成新的 `state` ；Vuex 则通过 `commit` 执行对应的 `mutation` 去修改 `state`
- 不同点：
  最大的区别在于**异步处理**；Redux 是通过中间件处理的，而 Vuex 是在 action 之后，commit 之前处理异步

## Vue 的插件原理了解过吗？ I
调用 `Vue.use(plugin)` 的时候，会调用插件的 `install` 方法，并且将 Vue 作为第一个参数传入，插件的挂载可以在 `install` 方法中进行，例如 `Vuex` 的 `install` 方法中就把 `store` 挂载到了 `Vue` 的上下文环境中。

## 对 MVVM 的理解
MVVM 是 Model-View-ViewModel 的缩写

- Model: 代表数据模型，**数据**和**业务逻辑**都是在 Model 层中定义的，它**只关心数据**本身，而不关心任何行为
- View: 代表 UI 界面，负责对数据的展示
- ViewModel: 负责监听 Model 中**数据的改变**和控制**视图的更新**，处理**用户交互操作**；Model 和 View 没有直接关联，而是通过 ViewModel 来进行**绑定**，从而实现：
  - Model 中的数据改变时，会触发 View 层的更新
  - View 中由于用户交互操作触发事件而改变的数据也会通过 ViewModel 修改 Model 。

## Vue 双向绑定的实现 III
Vue 主要是通过**数据劫持**结合**发布者-订阅者模式**实现双向绑定的。

- 数据劫持就是通过遍历 vue 实例的 data 属性，用 defineProperty 对数据的访问器属性 getter/setter 进行劫持，在 getter 中收集订阅者（依赖）(`deps<Watcher>`)，在 setter 中发布消息给订阅者，触发**响应监听回调**(`dep.notify()`)。
- vue 的数据双向绑定将 MVVM 作为数据绑定的入口，整合 `Observer`, `Compile` 和 `Watcher` 三者
  - 通过 `Observer` 来监听 `model` 的数据变化，**通知订阅者**；
  - 通过 `Compile` 来解析编译模板指令，**绑定订阅者**；
  - 利用 `Watcher` 搭起通信桥梁，收到属性的变化，触发视图更新。
    
从而实现了双向绑定。

## 双向绑定和 vuex 是否冲突 II
   在严格模式下使用 Vuex 时，在属于 vuex 的 state 上直接使用 v-model 会比较棘手，由于这个修改不是在 mutation 中执行的，这里会抛出一个错误。
   **解决方法：**
   
   ```html
    <input v-model="message">
    <script>
        export default {
            computed: {
                message: {
                    get() {
                        return this.$store.state.obj.message;
                    },
                    set(val) {
                        this.$store.commit('updateMessage', val)
                    }
                }
            }
        }
    </script>
   ```
   
## Vue 3 了解过吗？II

### 跟 Vue 2 的区别是什么？ II
答：
 
 1. 双向绑定的实现上； defineProperty & proxy
 2. 生命周期的改变；
   - 使用 setup 代替了之前的 beforeCreate 和 created，其他生命周期命名都添加了 on 前缀
 3. TypeScript 的支持；
   - vue3 就是用 ts 写的，很好的支持了 typescript
 4. 借鉴了 react hook 提出了 composition api
 5. 事件缓存
 6. reconcilitation 上的突破：blockTree ~ openBlock
   - 首先是**static hoisting 静态提升**，编译器会检测模板中的静态节点，在生成 render 函数代码的时候会把静态节点提取到渲染函数外，保留对其引用，避免了静态节点的重复渲染
   - 其次是 **patch flags 更新类型标记**，对于一个有动态绑定的 element，同样可以在编译阶段得到一些信息，Vue 在创建 vnode 时中直接通过 patch flag 标记了它们的更新类型；另外，vue 还能标记一个 vnode 节点的子节点类型，例如一个 template 有多个根节点就会别当作一个 fragment，大多是时候我们都能够确定这些节点的顺序时不会改变的，运行时因此可以跳过对这个根片段中子元素顺序的重新协调过程。
   - 最后就是 **树结构打平 tree flattening**，它引入了一个概念“区块(block)”，内部结构是稳定的一个部分可被称之为一个区块，每个区块会追踪它的所有包含**更新类型标记**的后代节点，不只是直接子节点；一个 "block" 经过 tree flattening 之后的结果是一个只包含动态后代节点的数组，当组件需要 re-render 的时候，只需要遍历这个扁平化数组，而不是整棵树，这大大减少了在 vdom 协调时需要遍历的节点数量。模板中的静态部分会被高效地略过

### Vue 3 和 Vue 2 在双向绑定的实现上有什么不同？

答：Vue 的双向绑定是通过数据劫持结合发布订阅模式实现的。在 Vue3 中是通过代理的方式实现数据劫持的，而 Vue2 是通过 defineProperty 方法实现

### Vue3 使用代理的方式实现数据劫持有什么好处？I
答：
 
  - Vue2 中的实现原生无法监测到数组和对象新增/删除属性的变化，需要手动改造数组方法；而通过 Proxy 代理则可以从原生直接支持监测数组的变化
  - Vue2 中实现数据劫持是通过**递归遍历**对对象属性的访问器属性的 set/get 进行改造实现的，拦截的是对象属性，如果递归层级较深的话就会有性能问题；而 Vue3 使用 Proxy 代理的是整一个对象。
  - Proxy 除了支持对 get/set 进行拦截，还支持11种拦截。


## Vue 的 nextTick 了解过吗？III
当在 Vue 中更改响应式状态时，最终的 DOM 更新并不是同步生效的，而是由 Vue 将它们缓存在一个队列中，直到下一个“tick”才一起执行。这样是为了确保每个组件无论发生多少状态改变，都仅执行一次更新。

nextTick() 可以在状态改变后立即使用，以等待 DOM 更新完成。

nextTick 可以让我们在下次 DOM 更新完全结束之后执行延迟回调。
nextTick 的实现采用了**优雅降级**的方式实现执行延迟回调：

- 优先使用 Promise
- 其次是 MutationObserver
- 然后是 setImmediate
- 最后是 setTimeout

**使用场景**

- 在 mounted / updated 钩子函数中，不会承诺所有的子组件也都一起被挂载或者已更新，想要等到整个视图渲染完毕之后做一些操作时，应该在 mounted / updated 中使用 nextTick。

## 如果要你写模板渲染你会怎么写？II

在 Vue 中我们一般使用**模板语法**，它是一种**领域专用语言(Domain Specific Language - DSL)**，我们最终要把 vue 文件中的模板转换成我们想要渲染到视图中的真实的 DOM。

在模板语法中，有很多像是双向绑定或者其他以 v- 开头的指令语法、动态属性值以及其他 javascript 语法存在，所以首先要定义一种模板语法，第一个需要解决的就是对这些语法进行转义：

- 使用大量的正则表达式对他们进行匹配，最终生成一个 javascript 对象，我们叫做抽象语法树（AST）。

那么这个 javascript 对象怎么转换成真实 dom 节点呢？参考 react 的jsx编译原理，我们可以把这个过程进行拆分：

- 先转换成一个渲染函数；渲染函数就是通过拼接函数字符串，然后通过 new Function 转换成一个函数。
- 最后把 VDOM patch到我们的视图当中，也就是转换成真实 dom 节点。

总结一下流程就是：

1. 把使用正则表达式对模板语法进行匹配和转义，转换成**抽象语法树**；
2. 将我们的抽象语法树转换成**渲染函数**
3. 执行渲染函数，生成真实 DOM 节点（先生成 VDOM、再做 diff、patch 成真实 DOM, 最小化渲染）；

具体实现方法：

1. 模板语法转义生成 AST - 通过正则表达式匹配和转义
2. AST 生成模板函数

    思路就是递归遍历 ast 树，对不同的类型节点，调用不同的生成函数字符串，最后组合成为模板函数字符串，最后通过 new Function 生成一个真正函数，就是我们的渲染函数。
3. 结合数据运行，把数据作为参数传入渲染函数中。

## computed 和 Watch 的区别？II
- Computed property is the place where you can do some calculation and memorization. Only when the relate reactive data changed, the it would re-calculate the result.
- While the Watch property is a way to monitor a data which would be wrapped in the watch hook within the Vue and execute the callback whenever the data changed.

In summary, if you wanna calculate some complex data or memorization, the computed property is what you need. While if you wanna do something when the data changed, you can use the watch property.

## Vue.mixin了解过吗？ I
mixin 提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。

本质其实就是一个 js 对象，它可以包含组件中的任意选项。只要将公用的功能以对象的方式传入 mixin 选项中，当组件使用 mixins 对象时，所有 mixins 对象的选项都将被混入该组件本身的选项中。
在 Vue 中可以进行局部混入和全局混入。

注意：

- 当组件存在与 mixin 对象相同的选项的时候，进行递归合并时已存在的选项会覆盖 mixin 的选项
- 而如果相同选项为生命周期钩子的时候，会合并成一个**数组**，先执行 mixin 的生命周期，再执行组件的钩子。

Vue 中几种类型的合并策略

- 替换型: props、methods、inject、computed
- 合并型: data
- 队列型: 生命周期和 watch, 且 mixin 先执行，组件自身的钩子后执行
- 叠加型: component、directives、filters
    
## 说说你对 keep-alive 的理解是什么？怎么缓存当前的组件？缓存后怎么更新？
1. keep-alive 是什么？

    keep-alive 是 vue 中的内置组件，它能够将不活动的组件实例保存在内存中，而不是直接将其销毁，它是一个抽象组件，不会被渲染到真实 DOM 中，也不会出现在父组件链中。简单来说，keep-alive 用于保存组件的渲染状态，避免组件反复创建和渲染，有效提升系统性能。
    
    keep-alive 可以设置一下 props 属性：
    
    - include - 字符串或正则表达式，只有名称匹配的组件会被缓存
    - exclude - 同上，名称匹配不会被缓存；
    - max - 数字，最多可以缓存的组件实例数量
2. 使用场景

    当我们不希望让页面重新加载时可以使用 keep-alive
3. 原理分析
   1. 使用 LRU 缓存机制进行缓存，max 限制缓存表的最大容量；
   2. 根据设定的 include/exclude 进行条件匹配，决定是否缓存，不匹配，直接返回组件实例
   3. 根据组件的一些标识符号 (cid 和 tag) 生成 key，并在 cache 对象中查找是否已缓存过该组件实例。如果存在，直接取出缓存值并更新该 key 在 keys 中的位置（放到数组末尾，更新 keys 是实现 LRU 置换策略的关键）；如果不存在，将该组件实例放入缓存中，并且将它的 key 值 push 到 keys 数组中，当缓存的组件实例数量超过了 max，会淘汰 keys 的第一个 key 和 cache 中对应的组件实例。
   4. 返回组件实例
4. 缓存后怎么加载数据？

    解决方案有以下两种：
    
    - beforeRouteEnter
    - actived

    **beforeRouteEnter**，每次组件渲染的时候，都会执行

    **actived**，在 keep-alive 缓存的组件被激活时，都会执行。但是 SSR 期间不支持
    
## Vue-Router
### 实现原理
原理的核心就是更新视图但不重新请求页面，路径之间的切换，也就是组件的切换。 `vue-router` 实现单页面路由跳转模式包括：
- hash 模式：通过锚点值的改变，根据不同的值，渲染指定 DOM 位置的不同数据。每一次改变 `#` 后的部分，都会在浏览器的访问历史中增加一个记录，点击后退按钮，就可以回到上一个位置。
- history 模式：利用 window.history.pushState API 来完成 URL 跳转而无需重新加载页面
#### VueRouter 的实现

##### install 方法
通过 Vue.mixin 全局注入 `beforeCreate` 生命周期函数，在每个组件的 `beforeCreate` 生命周期去执行

```js
    beforeCreate() {
        if (this.$options.router) { // 根组件
            this._routerRoot = this
            this.$router = this.$options.router
            this.$router.init(this)
        } else { // 非根组件
            this._routerRoot = this.$parent && this.parent._routerRoot
            this.$router = this._routerRoot.$router //子组件挂上 $router
        }
    }
```

##### createRouteMap 方法
这个方法是将传进来的 routes 数组转成一个 map 结构，key是 path, value 是对应的组件信息。

```js
	function createRouteMap(routes) {
	    const pathList = []
	    const pathMap = {}
	    routes.forEach(route => {
	        addRouteRecord(route, pathList, pathMap)
	    })
	    return { pathList, pathMap }
	}
	function addRouteRecord(route, pathList, pathMap, parent) {
	    const path = parent ? `${parent.path}/${route.path}` : route.path
	    const { component, children = null } = route
	    const record = {
	        path,
	        component,
	        children
	    }
	    if (!pathMap[path]) {
	        pathList.push(route.path)
	        pathMap[path] = record
	    }
	    if (children) {
	        children.forEach(child => addRouteRecord(child, pathList, pathMap, record))
	    }
	}
```

#### hash 模式的实现

实现基类框架 `HashHistory`

```js
	class HashHistory {
	    constructor(router) {
	        this.router = router
	        ensureSlash() // 如果 url 中没有 '#' 自动填充
	        this.setupHashListen() // 监听 hash 变化
	    }
	}
```

##### 怎么实现`#`后面的 url 变化改变视图
1. 首先，实现 url 变化触发响应回调 `onHashChange`
2. `onHashChange` 中获取当前 url, 传给视图转换回调 `transitionTo`
3. `transitionTo` 中调用 `createMatcher` 找出所有对应的组件，并改变当前 `route`
4. 通过 `vue` 的 `defineReactive` 实现对 `history.current` 的劫持

    ```js
	    constructor(options) { // HashHistory
	        this.current = createRoute(null, {
	            path: '/'
	        })
	    }
	    onHashChange() {
	        this.transitionTo(window.location.hash.slice(1))
	    }
	    transitionTo(location) { // within HashHistory
	        const route = this.router.createMatcher(location)
	        this.current = route
	    }
	    // within Router
	    init(app) {
	        this.history.listen((route) => app._route = route)
	        this.history.transitionTo(window.location.hash.slice(1))
	    }
	    createMatcher(location) {   
	        const { pathMap } = createRouteMap(this.options.routes)
	        const record = pathMap[location]
	        const local = {
	            path: location
	        }
	        return createRoute(record || null, local)
	    }
	
	    createRoute(record, location) {
	        const res = []
	        while (record) {
	            res.unshift(record)
	            record = record.parent
	        }
	        return { ...location, matched: res }
	    }
	    // 在跟组件的 beforeCreate 回调中对 _route 进行监听
	    // 相当于存在 _routerRoot 上
	    Vue.util.defineReactive(this, '_route', this.$router.history.current)
	    // 在 install 方法中劫持 $route
	    Object.defineProperty(Vue.prototype, '$route', {
	        get() { return this._routerRoot._route}
	    })
    ```
    
#### 实现 router-view

```js
	const myView = {
	    functional: true,
	    render(h, { parent, data }) {
	        const { matched } = parent.$route
	        data.routerView = true // 标识此组件为 router-view
	        let depth = 0 
	
	        while (parent) {
	            if (parent.$vnode && parent.$vnode.data.routerView) {
	                depth++
	            }
	            parent = parent.$parent
	        }
	        const record = matched[depth]
	        if (!record) return h()
	        return h(record.component, data)
	    }
	}
```

#### 实现 router-link

实际上就是 a 标签

```js
	export default const myLink = {
	    props: {
	        to: { type: String, required: true }
	    },
	    render(h) {
	        return h('a', {
	            domProps: {
	                href: '#' + this.to,
	            }
	        }, [this.$slots.default])
	    }
	}
```

### 有哪些钩子
- 全局守卫
  - 全局**前置**守卫 - `beforeEach` 注册全局前置守卫，当一个导航触发时，全局前置守卫按照创建顺序调用。守卫是异步解析执行的，此时导航在所有守卫 `resolve` 之间都属于**等待中**
  - 全局**解析**守卫 - `beforeResolve` 注册一个全局守卫，每次导航时都会触发，但是确保在导航被确认之前，**同时在所有组件内守卫和异步路由组件被解析之后，解析守卫就被正确调用。**`beforeResolve` 是获取数据或执行任何其他操作（如果用户无法进入页面时你希望避免执行的操作）的理想位置。
  - 全局**后置**守卫 - `afterEach` 不会接收 next 函数也不会改变导航本身，用于分析、更改页面标题、声明页面等辅助功能以及许多其他事情都很有用。它也反映了 `navigation failures` 作为第三个参数
- 路由独享守卫 - `beforeEnter` 只在进入路由时触发，**只有在从一个不同的路由导航时才会被触发**，也可以将一个函数数组传递给 `beforeEnter`，这在为不同的路由重用守卫时很有用。
- 组件内的守卫
  - `beforeRouteEnter` 不能访问 `this`, 因为守卫在导航确认前被调用，因此新组件还没被创建，不过可以通过传一个回调给 `next` 来访问组件实例，并且把组件实例作为回调方法的参数
  - `beforeRouteUpdate`
  - `beforeRouteLeave` 这个**离开守卫**通常用来预防用户在还未保存修改前突然离开。该导航可以通过返回 false 来取消。

#### 完整的导航解析流程
1. 导航被触发
2. 在失活的组件中调用 `beforeRouteLeave`
3. 调用全局 `beforeEach`
4. 在重用的组件里调用 `beforeRouteUpdate`
5. 否则在路由配置表里调用 `beforeEnter`
6. 解析异步路由组件
7. 在被激活的组件里调用 `beforeRouteEnter`
8. 调用全局的 `beforeResolve`
9. 导航被确认
10. 调用全局的 `afterEach` 钩子
11. 触发 DOM 更新
12. 调用 `beforeRouteEnter` 守卫中传给 `next` 的回调函数，创建好的组件实例会作为回调函数的参数传入。

## 为什么 data 属性是一个函数而不是一个对象？

组件实例对象中 data 必须是函数，目的是防止多个组件实例对象之间共用了一个 data, 产生数据污染。而函数每次都会返回一个新的对象，就不会有共用一个引用的问题。

## diff 算法
`diff` 算法是一种通过同层级的树节点进行比较的高效算法。

diff 算法在很多场景中都有应用，在 vue 中，作用于虚拟 dom 渲染成真实 dom 的新旧 VNode 节点比较

比较方式：`diff` 整体策略为：深度优先，同层比较

1. 比较只会在同层级进行，不会跨层级比较
2. 比较的过程中，循环从两边向中间收拢

原理分析：
当数据发生改变时，`set` 方法会调用 `Dep.notify` 通知所有订阅者 `Watcher`, 订阅者就会调用 `patch` 给真实的 `DOM` 打补丁，更新相应的视图。

`patch` 函数前两个参数位为 `oldVnode` 和 `Vnode`，分别代表新的节点和之前的旧节点，主要做了四个判断：

1. 没有新节点，直接触发旧节点的 `destory` 钩子
2. 没有旧节点，说明页面刚开始初始化的时候，直接调用`createElm` 
3. 旧节点和新节点自身一样，通过 `sameVnode` 判断节点是否一样，一样时，直接调用 `patchVnode` 去处理这两个节点
4. 不一样时，直接删除旧节点，创建新节点

其中的 `patchVnode` 主要做了几个判断：

1. 新节点是否是文本节点，如果是，则直接更新 dom 的文本内容为新节点的文本内容
2. 新节点和旧节点如果都有子节点，则处理比较更新子节点
3. 只有新节点有子节点，旧节点没有，那么不用比较了，直接全部新建就好了，新建是指创建出所有新的 dom 节点，并且添加进父节点
4. 只有旧节点有子节点，而新节点没有，说明更新后的页面旧节点全部都不见了，删除所有的旧节点的子节点，也就是直接把 DOM 删除。
5. vue 的虚拟 dom 渲染真实 dom 的过程中首先会对新老 `VNode` 的开始和结束位置进行标记：`oldStartIdx`, `oldEndIdx`, `newStartIdx`, `newEndIdx`
6. 标记好节点位置之后，就开始进入到循环处理中，这里是 `diff` 算法的核心流程，分情况进行了新老节点的比较并移动对应的 `VNode` 节点。循环退出的条件是老节点或者新节点的开始位置大于结束位置。
    `while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx)`
    循环中具体的处理逻辑是：首先对新老 `VNode` 节点的头尾进行比较，寻找相同节点，如果有相同节点满足 `sameVnode` 则直接进入 `patchVNode`(该方法进行节点复用处理)，并且根据不同情况，移动新老节点的 `VNode` 索引，然后进入下一次循环，一共有 4 种情况。
    1. 当新老 `VNode` 节点在 `start` 满足 `sameVnode` 时，直接 `patchVNode` 即可，同时新老 `VNode` 节点的开始索引都加一

    
        ```js
        if (sameVnode(oldStartVnode, newStartVnode)) {
            patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)
            oldStartVnode = oldCh[++oldStartIdx]
            newStartVnode = newCh[++newStartIdx]
        }
        ```
        
    2. 当新老 `VNode` 节点的 `end` 满足 `sameVnode` 时，直接 `patchVNode` 即可，同时新老 `VNode` 节点的结束节点索引都减 1
    3. 比较 `oldStartIdx` 和 `newEndIdx` 指向的 `VNode` 是否满足 `sameVnode`，如果满足，在 `patchVNode` 之后需要将当前真实 dom 节点移动到 `oldEndVnode` 的后面，同时 `++oldStartIdx` 和 `--newEndIdx`
    4. 比较 `oldEndIdx` 和 `newStartIdx` 指向的 `VNode` 是否满足 `sameVnode`，如果满足，在 `patchVNode` 之后需要将当前真实 dom 节点移动到 `oldStartVnode` 的前面，同时 `--oldEndIdx` 和 `++newStartIdx`
    5. 如果都不满足，说明没有相同的节点可以复用，于是则通过查找之前建立好的以旧的 `VNode` 为 `key` 值，对应 index 序列为 value 值的哈希表。从这个哈希表中找到与 `newStartVnode` 一致的旧的 `VNode` 节点，如果两者满足 `sameVnode` 的条件，在进行 `patchVnode` 的同时，会将这个真实 dom 移动到 `oldStartVnode` 对应的真实 dom 的前面；如果没有找到，说明当前索引下的新的 `VNode` 节点在旧的 `VNode` 队列中不存在，那么就只能调用 `createEle` 创建一个新的 dom 节点放到当前的 `newStartIdx` 的位置。
7. 当循环结束后，根据新老节点的数目不同，做节点添加或删除。若新节点数目大于旧节点则需要把多出来的节点创建出来，加入到真实 dom 中，反之若老节点数目大于新节点则需要把多出来的老节点从真实 dom 中删除。至此整个 diff 过程就已经全部完成了。

    ```js
    if (oldStartIdx > oldEndIdx) {
        // 该条件说明新节点数目大于旧节点，需要创建
        refElm = isUnDef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm
        addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue) // 创建 newStartIdx ~ newEndIdx 之间的所有节点
    } else if (newStartIdx > newEndIdx) {
        removeVnodes(oldCh, oldStartIdx, oldEndIdx)
    }
    ```
    


# React
## Why the reducers must not have side-effect? I
The purpose of this rule is to guarantee that reducers will behave predictably when called. For example, if you are doing time-travel debugging, reducer functions may be called many times with earlier actions to produce the "current" state value. If a reducer has side-effects, this would cause those effects to be executed during the debugging process, and result in the application behaving in unexpected ways.

这个规则的目的是保证 reducer 被调用时的行为时可预测的。例如，如果你在做 time-travel debugging，reducer 方法可能在之前调用了很多次 actions 才产生了"现在"的 state，如果一个 reducer 有 side-effects，这些 side-effects 可能会在 debugging 期间被执行，导致应用的非预期行为。
    

## hooks
### 什么是 hooks? 为什么要用 hooks?
Hooks 可以在不用编写 class 的情况下使用 state 以及其他的 React 特性。

Hooks 的引入是为了解决：

- 难以重用和共享组件中的与状态相关的逻辑

    以往没有好的方法可以将可复用性的逻辑附加到组件，只能通过 render prop 或 HOC, 就像 react-redux 的 connect 函数一样，一旦类似的逻辑多了，就容易陷入嵌套地狱，而 hook 可以很方便的提取可复用的逻辑，不需要依赖组件结构，就可以在组件中使用
    
- 逻辑复杂的组件难以开发与维护，当组件需要处理多个互不相关的 local state 时，每个生命周期函数中可能会包含着各种互不相关的逻辑在里面
- 类组件的 this 增加学习成本，类组件在基于现有工具的优化上存在些许问题
- 由于业务变动，函数组件不得不改为类组件

Hooks 的定义：React 组件显然更应该是一个函数（而不是类）。而 hooks 就是让函数组件具有 state 和 react 特性的能力，从而解决以上问题。
在以前，函数组件也被称为无状态的组件，只负责渲染的一些工作。因此，现在的函数组件也可以是有状态的组件，内部也可以维护自身的状态以及做一些逻辑方面的处理。

### 有哪些 hooks?
- useState
- useEffect: asynchronous callback
 - 可以在每次渲染完之后做一些事情
 - 通过提供第二个依赖数组参数，只有当数组中的某一个值发生改变时才执行副作用
 - 副作用回调支持返回一个函数，用于清除 effect 副作用，相当于 `componentUnMount`
 - 可以让副作用分离，通过多个 useEffect 根据不同的依赖执行不同的副作用
- useLayoutEffect: sync callback
- useReducer
- useCallback
- useMemo
- useRef

### 自定义 hooks
前面提到 hooks 解决状态逻辑的重用问题，我们可以轻松的将组件逻辑提取出来到自定义的 hook 中，然后在各个组件中使用。
需要注意的是：

- hook 在各个组件中的 state 状态是隔离的，这个跟 js 函数的概念是一致的。
- 它不是用来在多个组件中复用状态，而是在多个组件中**复用状态逻辑**。

### hooks 规则
1. **只在最顶层使用 hook**。保证 hook 的调用顺序一致，也就是不要在循环、条件或者嵌套函数中调用 hook, 这样可以做到各个 hook 在每一次渲染中，调用顺序是一致的，这与 React 实现 hook 的原理有关，每次渲染时，React 把所有调用的 hook 用数组存储
2. **只在 React 函数组件中使用**。

### 优缺点
优点：

- 编写 hooks 为函数式编程，每个功能都包裹在函数中，整体风格更简洁，可读性高
- hooks 的出现，使函数组件的功能得到了扩充，拥有了类组件相似的功能，在日常使用中，使用 hooks 能够解决大多数问题，并且还拥有代码复制机制，因此优先考虑 hooks。

缺点：部分生命周期函数还未实现，必要的时候仍然需要换成 class 组件


## 生命周期 III
- 挂载
    - constructor
    - static getDerivedStateFromProps
    - render
    - componentDidMount
- 更新
    - static getDerivedStateFromProps
    - shouldComponentUpdate
    - render
    - getSnapshotBeforeUpdate
    - componentDidUpdate
- 卸载
    - componentWillUnmount
- 错误处理
    - static getDerivedStateFromError()
    - componentDidCatch()

## 挂载阶段

### constructor

实例过程中自动调用的方法，在方法内部通过 super 关键字获取来自父组件的 props。

该方法中通常的操作仅用于以下两种情况：

- 初始化 state 状态
- 为事件处理函数绑定实例

### static getDerivedStateFromProps

该方法是新增的生命周期方法，是一个静态方法，因此不能通过实例访问。

执行时机：组件创建和更新阶段，不论是 props 或者 state 变化都会调用。

在每次 render 方法前调用，第一个参数为即将更新的 props，第二个参数为上一个状态的 state，可以比较 props 和 state 来加一些限制条件，防止无用的 state 更新。

该方法需要返回一个新的对象作为新的 state 或者返回 null 表示 state 状态不需要更新。

**什么时候使用 derived state？**

getDerivedStateFromProps 的存在只有一个目的：让组件在 **props 变化**时更新 state。比如

- [props 的 offset 变化时，修改当前的滚动方向](https://zh-hans.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#updating-state-based-on-props)
- [根据 props 变化加载外部数据](https://zh-hans.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#fetching-external-data-when-props-change)
    
    ```jsx
    class ExampleComponent extends React.component {
    	state = { externalData: null }
    	static getDerivedStateFromProps(props, state) {
    		// 保存 prevId 在 state 中，以便我们在变化时进行对比。
    		// 清除之前加载的数据（这样我们就不会渲染旧的内容）
    		if (props.id !== state.prevId) {
    			return {
    				externalData: null,
    				prevId: props.id,
    			}
    		}
    		// no need to update state
    		return null;
    	}
    	componentDidUpdate() {
    		if (this.state.externalData === null) {
    			this._loadAsyncData(this.props.id);
    		}
    	}
    	_loadAsyncData(id) {
    		this._asyncRequest = loadMyAsyncData(id).then(
    			externalData => {
    				this._asyncRequest = null;
    				this.setState({externalData})
    			}
    		)
    	}
    }
    ```
    

**什么时候不应该使用？**

- 如果你需要执行副作用（例如，数据提取或动画）以响应 props 中的更改，改用 componentDidMount。
- 如果只想在 prop 更改时重新计算某些数据，使用 memorization。
- 如果你想在 prop 更改时重置某些 state，考虑使组件完全受控，或者使用 key 使组件完全不受控

注意，不管原因是什么，都会在每次渲染前触发此方法。与 UNSAFE_componentWillReceiveProps 形成对比，后者仅在父组件重新渲染时触发，而不是在内部调用 setState 时。

### render

类组件必须实现的方法，用于渲染 DOM 结构，可以访问组件 state 与 prop 属性，但不要在 render 中 setState，否则会引发死循环。

### componentDidMount

**组件挂载到真实 DOM 节点后执行**，其在 render 方法之后执行。

如果需要通过网络请求获取数据，此处是实例化请求的好地方。

同时，这个方法是比较适合添加订阅的地方，如果添加了订阅，不要忘记在 componentWillUnmount() 里取消订阅。

另外，如果你依赖 DOM 节点的位置或大小，比如实现 modals 或 tooltips 等情况下，你可以使用此方法处理

## 更新阶段

### getDerivedStateFromProps

同上

### shouldComponentUpdate

用于告知组件本身基于当前的 props 和 state 是否需要重新渲染组件，默认情况返回 true

执行时机：到新的 props 或者 state 时都会调用，通过返回 bool 值告知组件更新与否。

一般情况下，不建议在此方法中进行深层比较或使用 JSON.stringify()，会影响效率，同时也不能调用 setState，否则会引发无限循环调用更新。

### render 同上

### getSnapshotBeforeUpdate

在最近的一次输出（提交到 DOM 节点）之前调用。它使你的组件能够在它可能被改变之前，从dom 获取到一些信息（例如滚动位置）。该方法返回的一个 Snapshot 值，作为 **componentDidUpdate** 的第三个参数传入。

> **注意**
getSnapshotBeforeUpdate 方法从 DOM 获得的值将引用 **DOM 更新之前的值**，即使之前调用了 render 方法。
> 

这个方法不常见，但它可能出现在 UI 处理中，如：需要以特殊方式处理滚动位置的聊天线程等。

例如：

```jsx
class ScrollingList extends React.Component {
	constructor(props) {
		super(props);
		this.listRef = React.createRef()
	}

	getSnapshotBeforeUpdate(prevProps, prevState) {
		// Are we adding new items to the list?
		// Capture the scroll position so we can adjust scroll later
		if (prevProps.list.length < this.props.list.length) {
			const list = this.listRef.current;
			return list.scrollHeight - list.scrollTop
		}
		return null
	}
	componentDidUpdate(prevProps, prevState, snapshot) {
		// if we have a snapshot value, we've just added new items.
		// Adjust scroll so these new items don't push the old ones out of the view.
		if (snapshot !== null) {
			const list = this.listRef.current;
			list.scrollTop = list.scrollHeight - snapshot
		}
	}
	render() {
		return (
			<div ref={this.listRef}>{/*contents...*/}</div>
		)
	}
}
```

在上述示例中，重点是从 getSnapshotBeforeUpdate 读取 scrollHeight 属性，因为 “render” 阶段生命周期和 “commit”阶段生命周期（如 getSnapshotBeforeUpdate 和 componentDidUpdate）之间可能存在延迟。

此方法的目的在于获取组件更新前的一些信息，比如组件的滚动位置，在组建更新后可以根据这些信息回复一些 UI 视觉上的状态。

### componentDidUpdate

```jsx
componentDidUpdate(prerProps, prevState, snapshot)
```

执行时机：组将更新结束后触发

在该方法中，可以根据前后的 props 和 state 的变化做相应的操作，如获取数据，修改 DOM 样式等。

也可以在此方法中直接调用 setState，但它必须被包裹在一个条件语句里，上述的例子也需要这么处理，否则会导致死循环。它还会导致额外的重新渲染，虽然用户不可见，但会影响组件性能。

> **注意**
如果 shouldComponentUpdate 返回值为 false，则不会调用 componentDidUpdate()。
> 

## 卸载阶段

### componentWillUnmount

此方法用于组件卸载前，清理一些注册监听事件，或者取消订阅的网络请求等。一旦一个组件实例被卸载，其不会被再次挂载，而只可能是被重新创建。

## 错误处理

有时候组件会出现问题，会抛出错误。当后代组件抛出错误时，将调用下面的方法。

### static getDerivedStateFromError()

```jsx
    static getDerivedStateFromError(error): State
```

当后代组件抛出错误时，首先会调用这个方法，并将抛出的错误作为参数。并返回一个值以更新 state。

> **注意
getDerivedStateFromError 会在 渲染阶段调用，因此不允许出现副作用。如遇此类情况，改用 componentDidCatch()**
> 

### componentDidCatch()

```jsx
    componentDidCatch(error, info)
```

当后代组件抛出错误时也会调用这个方法，它接受两个参数：

1. error - 被抛出的错误
2. info - 包含了有关错误的更多信息：具有 componentStack 键的对象，其中包含有关哪个组件引发错误的信息。

componentDidCatch 是在 “commit” 阶段被调用的，所以是允许副作用的。它应该用于记录错误信息之类的事：

```jsx
componentDidCatch(error, info) {
	logComponentStackToMyService(info.componentStack)
}
```

## What is React Fiber?  II
Fiber is the new *reconciliation* engine and reimplementation of core algorithm in React v16. The goal of React Fiber are:

1. Ability to split interruptible work in chunks.
2. Ability to prioritize, rebase and reuse work in progress.
3. Ability to yield back and forth between parents and children to support layout in React.
4. Ability to return multiple elements from render().
5. Better support for error boundaries.

JS 引擎和渲染引擎线程是互斥的，当其中一个线程执行时，另一个线程只能挂起等待。
如果 JS 线程长时间地占用了主线程，那么渲染层面的更新就不得不长时间地等待，界面长时间不更新，会导致页面响应变差，用户可能会感觉到卡顿

而这也是 React 15 的**调和**引擎所面临的问题，当 React 渲染组件时，从开始到渲染完成整个过程无法中断，如果组件较大，那么 js 线程会一致执行，然后等到整棵 VDOM 树计算完成后，才会交给渲染的线程。

这就会导致一些用户交互、动画等任务无法立即得到处理，导致卡顿。

Fiber 是 React16 的一个新的**调和**引擎和核心算法的重新实现。React Fiber 的目的在于提供：

1. 把可打断的大型复杂工作进行分片的能力；
2. 对任务划分优先级，优先调度高优先级的任务；
3. 增加了异步任务，调用 **requestIdleCallback** api, 浏览器空闲时执行
4. 调度过程中，可以让任务进行挂起、恢复、终止等操作

- 从架构角度来看，Fiber 是对 React 核心算法（即调和过程）的重写。
- 从编码角度看，Fiber 是 React 内部所定义的一种数据结构，它是 Fiber 树结构的节点单位，也就是 React 16 新架构下的虚拟 DOM。

`window.requestIdleCallback()`方法将在浏览器的空闲时段内调用的函数排队。这使开发者能够在主事件循环上执行后台和低优先级工作，而不会影响延迟关键事件，如动画和输入响应

首先 React 中任务切割为多个步骤，分批完成。在完成一部分任务之后，将控制权交回给浏览器，让浏览器有时间再进行页面的渲染。等浏览器忙完之后有剩余时间，再继续之前 React 未完成的任务，是一种合作式调度。

该实现过程是基于 Fiber节点实现，作为静态的数据结构来说，每个 Fiber 节点对应一个 React element，保存了该组件的类型（函数组件/类组件/原生组件等等）、对应的 DOM 节点等信息。

作为动态的工作单元来说，每个 Fiber 节点保存了本次更新中该组件改变的状态、要执行的工作。

每个 Fiber 节点有个对应的 React element，多个 Fiber节点根据如下三个属性构建一颗树：

```js
// 指向父级Fiber节点
this.return = null
// 指向子Fiber节点
this.child = null
// 指向右边第一个兄弟Fiber节点
this.sibling = null
```
	
通过这些属性就能找到下一个执行目标


## What is JSX? II
JSX is a XML-like syntax extension to ECMAScript(the acronym stands for *JavaScript XML*). Basically it just provides syntastic suger for the **React.createElement()** function, giving expressiveness of JavaScript along with HTML-like template syntax.

JSX 是一种对 ECMAScript 的类 XML 的语法扩展，它提供了语法糖给 React.createElement() 函数，提供了 JavaScript 的表达能力和类 HTML 的模板语法。

为什么不用模板？

React 团队认为不应该把关注点放到模板上，避免引入更多概念。

Babel 插件怎么实现 JSX 到 JS 的编译？
Babel 读取代码并解析生成 AST, 将 AST 输入插件中进行转换，转换的结果就是生成 React.createElement() 

## What is Virtual DOM?
The *Virtual DOM*(VDOM) is an in-memory representation of the real DOM. The representation of a UI is kept in memory and synced with the real DOM. 
It's a step that happens between render function being called and the displaying of element on the screen. This entire process is called reconciliation.

虚拟 DOM 是一种真实 DOM 节点的表现形式，UI 的表现形式存在一个对象中，并且与真实 DOM 同步更新。
它在 render 函数被调用后，元素显示在屏幕之前产生。这一整个过程被称为调和。

## How Virtual DOM works? II
The Virtual DOM works in three simple steps.

1. Whenever any underlying data changes, the entire UI is re-rendered in Virtual DOM representation.
2. Then the difference between the previous DOM representation and the new one is calculated.
3. Once the calcutations are done, the real DOM will be updated with only the things that have actually changed.

虚拟 DOM 通过三个简单的步骤工作。

1. 当任何潜在数据改变时，整个 UI 会以虚拟 DOM 的表现形式重新渲染；
2. 然后计算之前的虚拟 DOM 和这个新的区别；
3. 一旦计算结束，真实 DOM 将会只更新发生了改变的那部分；
   
## What are Stateful and Stateless component? II

In React apps, whether a component is stateful or stateless is considered an implementation detail of the component that *may change over time*.
If the behavior of the component is independent of its *state* then it can be a stateless component. Otherwise, if the behavior of the component is dependent on its *state* then it can be termed as stateful component.

## What are Uncontrolled and controlled component? I
A component that controls the input element within the forms on subsequent user input is called **controlled component**. i.e, every state mutation will have an associated handler function.

The **Uncontrolled component** are the ones that store their own state internally, and you query the DOM using a ref to find its current value when you need it. This is a bit more like traditional HTML syntax.

In most cases, it's recommend to use **controlled components** to implement forms. In a controlled component, form data is handled by a React component.

## What's the different between DOM element and component element?   II
The DOM element is an element that’s a string; 

The component element is a class or a function;

It is important to understand that both types are simple objects. They are mere descriptions of what must be rendered on the screen and don’t instigate rendering when you create and instantiate them.(它们只是对必须在屏幕上呈现的内容的描述，并且不会在您创建和实例化它们时引发呈现)

## What is the different between Presentational component and Container component?
- **Presentational components:**
  - Are concerned with how things look(makeup & styles)
  - Often allow containment via props.children
  - Have no deps on the rest of the app, such as redux actions or stores.
  - Don't specify how the data is loaded or mutated.
  - Receive data and callbacks exclusively via props.
  - Rarely have their own state (when they do, it's UI state rather than data)
  - Pure and tend to stateless (but also can be stateful)
  - Examples: Page, Sidebar, Story, UserInfo, List

  - 只关心渲染了什么
  - 通常会使用 props.children
  - 在整个 app 中没有依赖，例如 redux actions 或 stores
  - 不关心数据怎么被加载或被改变的；
  - 只通过 props 接收数据和回调函数；
  - 很少有自己的 state，如果有，那它只是 UI state 和不是数据
  - Pure 且倾向于无状态的，但也可以是有状态的；
  - 例如：页面，侧边栏，用户信息，列表

- **Container components:** A container does data fetching and then renders its corresponding sub-component.
  - Are concerned with how things work
  - May contain both presentaional and container components inside but usually don't have any DOM markup of their own except of some wrap divs, and never have any styles.
  - Provide the data and behavior to presentational or other container components.
  - Call Redux actions and provide these as callbacks to the presentational components.
  - Are often stateful, as they tend to serve as **data sources**.
  - May impure and tend to stateful (also can be stateless)
  - Examples: UserPage, FollowersSidebar, StoryContainer, FollowedUserList.

  - 只关心是怎么实现的
  - 可能包含表现组件和容器组件，但是通常没有他自己的 DOM 标记，除了一些用于包含的 divs，且没有任何样式
  - 提供数据和行为给表现组件或者其他容器组件
  - 调用 redux actions 的地方并且提供这些作为回调给表现组件；
  - 通常是有状态的，因为它们倾向于作为数据源；
  - 可能是不纯的，倾向于有状态的，也可以是无状态的
  - 例如：用户页面，关注者侧边栏，粉丝列表， 

Put them in different folders to make this distinction clear.

**Benefits**

- **Better separation of concerns**. You understand your app and UI better.
- **Better reusability**.
- **Logic abstraction**. You can put them on a single page and let the designer tweak all their variations without touching the app's logic.
- **Screenshot regression tests**.
- **Layout component introduction**. 
    This forces you to extract "layout components" such as Navigation, Page, ContextMenu and use this.prop.children instead of duplicating the same markup and layout in several container components.

Remember, components don't have to emit DOM. The only need to provide composition boundaries between UI concerns.

**优点**

- **利于分离关注点**，让你更好的理解应用和 UI。
- **利于复用**；
- **逻辑抽象**；你可以把它们放到一个页面中，让设计者调整所有变量，而不需要接触应用逻辑；
- **引入 layout 组件**；强迫你抽离 layout 组件，例如 Navigation, page, contextMenu 以及用 this.prop.children 而不是重复的在多个 container 组件写同样的标记和布局

**WHEN TO INTRODUCE CONTAINERS?**

When you notice some components don't use the props they receive but merely forward down and you have to rewrite all those intermediate components any time the children need more data, it's a good time to introduce some container components.

## What are Pure Components?

Pure Components 其实就是 React Component，只是它对 componentShouldUpdate 进行了改造，当 props 或 state 改变的时候，它只进行浅比较.

## What's the different between component and container in Redux?    II
- Component is a class or a function component that describes the presentational part of your application.
- Container is an informal term of the component that is connected to a redux store. Containers subscribe to Redux state updates and dispatch actions, and they usually don't render DOM elements; *They delegate rendering to presentational child component*.

## What's "key" prop and what is the benefit of using it in arrays of elements?  II
A key is a special string attribute you should include when creating arrays of elements. Key prop can helps React identify which item have changed, are added, or are removed.
Key 是一个特殊的属性，当你渲染一个数组元素的时候，你应该带上它。key 可以帮助 React 去识别哪个元素改变了、新增了或者删除了。

## In which scenarios error boundaries do not catch errors?  I
- Inside Event handlers
- Asynchronous code using setTimeout or requestAnimationFrame callbacks
- During SSR
- When errors throw in the error boundary code itself

- 事件处理器中
- 异步代码比如 setTimeout 或者 requestAnimationFrame 回调
- SSR 期间
- 出现在 error boundary 内部的错误

## Why do you not need error boundaries for event handlers?
Error boundaries do not catch errors inside event handler.

React doesn't need error boundaries to recover from errors in event handler. Unlike the render method, and lifecycle methods, the event handlers don't happen during rendering. So if they throw, React still knows what to display on the screen.

事件处理器不会在 render 期间被执行，所以如果出错了，React 仍然知道应该显示什么。

## diff algorithm
React 通过引入 Virtual DOM 极大地避免了无效的 DOM 操作，使我们的页面的构建效率得到了极大提升。

而 diff 算法就是更高效地通过对比新旧 VDOM 来找出真正的 DOM 的变化之处。

传统 diff 算法通过循环递归对节点进行依次对比，效率低下，算法复杂度达到了 O(n^3), React 将算法进行了优化，使复杂度降到了 O(n)

React diff 主要遵循三个层级的策略：

- tree 层级
- component 层级
- element 层级

- tree: DOM 节点跨层级的操作不做优化，只会对相同层级的节点进行比较。只有删除和创建操作，没有移动操作
- component: 如果是同一个类的组件则会继续往下 diff 运算，如果不是一个类的组件，那么直接删除这个组件下的所有节点，创建新的
- element: 对于比较同一层级的节点们，每个节点在对应的层级用唯一的 key 作为标识，提供三种节点操作：插入、移动和删除。
    通过 key 可以准确地发现新旧集合中的节点都是相同节点，因此无需进行节点删除和创建，只需要将旧集合中节点的位置进行移动，更新为新集合中节点的位置
    - index 新集合的遍历下标
    - oldIndex:当前节点在老集合中的下标
    - maxIndex 在新集合访问过的节点中，其在老集合的最大下标

    如果当前节点在新集合中的位置比老集合中的位置考前的话，是不会影响后续节点的操作的。

    操作过程值比较 oldIndex 和 maxIndex, 规则如下：
    
    - 当 oldIndex > maxIndex 时，将 oldIndex 的值赋值给 maxIndex
    - 当 oldIndex = maxIndex 时，不操作
    - 当 oldIndex < maxIndex 时，将当前节点移动到index 的位置

# Coding
- [X] 1. 找出数组中第二大的数

    ```js
        function findSecond(arr) {
            if (arr.length < 2) return
            let max = arr[0], second_max = Number.SAFE_MIN_VALUE
            arr.forEach((v, i) => {
                if (v > second_max) {
                    if (v > max) {
                        second_max = max
                        max = v;
                    } else if (v < max) {
                        second_max = v
                    }
                }
            })
            return second_max === Number.SAFE_MIN_VALUE ? undefined : second_max
        }
    ```
    
- [X] 2. 返回有序数组中目标值的索引

    ```js
        /**
         * {arr} the sorted array
         * {target} the target item
         */ 
        function findIndexInSortedArray(arr, target) {
            if (!arr.length) return -1
            let left = 0, right = arr.length - 1;
            while (right > left) {
                const mid = left + Math.floor(right - left / 2)
                if (arr[mid] > target) {
                    right = mid - 1
                } else if (arr[mid] < target) {
                    left = mid + 1
                } else {
                    return mid
                }
            }
            return -1
        }
    ```
    
- [X] 3. 给定一个二叉树，返回它的所有路径

    ```js
        function binaryTreePaths(root) {
            // dfs
            const paths = []
            function dfs(node, path) {
                if (node) {
                    path += node.val
                    if (!node.left && !node.right) {
                        paths.push(path)
                    } else {
                        path += '->'
                        dfs(node.left, path)
                        dfs(node.right, path)
                    }
                }
            }
            dfs(root, '')
            return paths
        }
        var binaryTreePaths = function(root) {
            // 广度优先搜索
            const paths = []
            const queue = [root]
            const paths_queue = [`${root.val}`]
            while (queue.length) {
                const cur = queue.shift()
                let cur_path = paths_queue.shift()
                if (!cur.left && !cur.right) {
                    paths.push(cur_path)
                } else {
                    if(cur.left) {
                        queue.push(cur.left)
                        paths_queue.push(`${cur_path}->${cur.left.val}`)
                    }
                    if (cur.right) {
                        queue.push(cur.right)
                        paths_queue.push(`${cur_path}->${cur.right.val}`)
                    }
                }
            }
            return paths
        };
    ```

- [X] 4. 防抖节流了解过吗？区别是什么？代码实现一下
   1. 防抖
        
        策略是当事件被触发时，设定一个周期延迟执行动作，若期间又被触发，则重新设定周期，直到周期结束，执行动作。即只让最后一次生效，前面的不生效。使用场景包括：输入文本校验，当用户在连续输入时不应该触发校验，而是在最后触发。

        ```js
            function debounce(callback, time) {
                let timer = null
                return function() {
                    if (timer) {
                        clearTimeout(timer)
                    }
                    const args = [...arguments];
                    const that = this
                    timer = setTimeout(() => {
                        callback.apply(that, args);
                    }, time)
                    }
                }
            }
        ```
        
   2. 节流

        策略是，固定周期内只执行一次动作，若有新事件触发，不执行；周期结束后，若有新事件触发，执行动作，然后开始新的周期。即在周期之前执行。例如：射击游戏的射速控制、给 resize 事件添加的事件处理器

        ```js
            function throttle(callback, time) {
                let timer = null;
                let lastTime = 0;
                return function () {
                    const curTime = Date.now()
                    if (lastTime + time > curTime) return
                    const args = [...arguments]
                    callback.apply(this, args)
                    lastTime = curTime
                }
            }
        ```

- [X] 5. 坐标轴中给定两个矩形的左上坐标和右下坐标，实现一个方法，判断这两个矩形是否重叠

    在二维空间中两个矩形重叠的条件是水平和垂直方向都有重叠的部分
    
    ```ts
        interface ISquare {
            lt: {
                x: Number;
                y: Number;
            };
            rb: {
                x: Number;
                y: Number;
            };
        }
        function isCovery(a: ISquare, b: ISquare): boolean {
            if (
                a.lt.x > b.rb.x /* a 在 b 左边 */ || b.lt.x > a.rb.x /* b 在 a 左边 */
                || a.rb.y > b.lt.y /* a 在 b 上面 */ || b.rb.y > a.lt.y /* b 在 a 上面 */
            ) return false
            return true
        }
    ```
    
- [X] 6. 定义一个函数，判断一个数是否为2的幂次方？怎么优化？(二进制方式)

    ```js
        function isPowerByTwo(num) {
            if (num <= 0) return false
            const res = Math.log2(num)
            return res === Math.floor(res)
        }
        // or 
        function isPowerByTwo(num) {
            return (num & (num-1)) === 0
        }
    ```
    
- [X] 7. 定义一个函数，用于解析url的query

    ```ts
        function parse(url: string) {
            const query = url.split("?")[1]
            return query ? query.split("&").reduce((queryObj, cur) => {
                const [key, val] = cur.split("=");
                queryObj[key] = val
            }, {}) : {}
        }
    ```
    
- [X] 8. 手写深拷贝，要考虑循环引用

    ```js
        function deepClone(target, hash = new WeakMap()) {
            if (target == null) return target // 返回 null || undefined
            if (target instanceof Date) return new Date(target)
            if (target instanceof RegExp) return new RegExp(target)
            // 函数不需要深拷贝，其他值类型直接返回
            if (typeof target !== 'object') return target
            // 避免循环引用导致无限循环
            if (hash.has(target)) return hash.get(target)
            // 创建同类型的拷贝对象
            const newObj = new target.constructor()
            // 关联当前 target 引用与新的值
            hash.set(target, newObj)
            // 深拷贝对象中所有的键值
            for (const key in target) {
                if (target.hasOwnProperty(key)) {
                    newObj[key] = deepClone(target[key], hash)
                }
            }
            return newObj
        }
    ```
    
- [ ] 9. 手写 jsonp
- [ ] 10. 找出数组的前 n 个最小值，并根据原数组先后顺序排序

    ```js
        function findPreMin(nums, n) {
            const len = nums.length
            if (len <= n) return nums
            const res = []
            let max = 0
            for (let i = 0; i < len; i++) {
                if (i < n) {
                    res.push(nums[i])
                    max = nums[max] > nums[i] ? max : i
                } else {
                    if (res[max] > nums[i]) {
                        res[max] = null
                        res.push(nums[i])
                        max = findMaxIndex(res)
                    }
                }
            }
            return res.filter(n => n || n == 0)
        }
    ```
    
- [X] 11. 手写 Promise.all 和 Promise.race()

    原生的 Promise.all 有什么特点？
    
    1. 接收一个可迭代对象
    2. 传入的数据中可以是普通数据，也可以是 Promise 对象
    3. 可迭代对象的 promise 是并行执行的
    4. 保持输入数组的顺序和输出数组的顺序一致
    5. 传入数组中只要有一个 reject, 立即返回 reject
    6. 所有数据 resolve 之后返回结果
 
	    ```js
	        function myPromiseAll(iterable) {
	            return new Promise((resolve, reject) => {
	                const promises = Array.from(iterable)
	                let count = 0;
	                let results = []
	                for (let i = 0; i < promises.length; i++) {
	                    Promise.resolve(promises[i]).then(res => {
	                        results[i] = res
	                        count++
	                        if (count === promises.length) {
	                            resolve(results)
	                        }
	                    }).catch(err => reject(err))
	                }
	            })
	        }
	    ```
	    
    7. Race
    
	    ```js
	    Promise.race = function (iterable) {
	        return new Promise(((resolve, reject) => {
	            const promises = Array.from(iterable)
	            for (let i = 0; i < promises.length; i++) {
	                Promise.resolve(promises[i]).then((data) => {
	                    resolve(data);
	                }).catch(err => reject(err))
	            }
		    ));
	    }
	    ```

- [ ] 12. 手写 Promise

    ```js
        // resolve & reject
        class MyPromise {
            constructor(executor) {
                this.initValue()
                this.resolve = this.resolve.bind(this)
                this.reject = this.reject.bind(this)
                try {
                    executor(this.resolve, this.reject)
                } catch(e) {
                    this.reject(e)
                }
            }
            initValue() {
                this.state = 'pending'
                this.result = null
                this.onFulfilledCallbacks = []
                this.onRejectedCallbacks = []
            }
            resolve(value) {
                // 状态不可变化
                if (this.state !== 'pending') return
                this.state = 'fulfilled'
                this.result = value
                while (this.onFulfilledCallbacks.length) {
                    this.onFulfilledCallbacks.shift()(this.result)
                }
            }
            reject(reason) {
                if (this.state !== 'pending') return
                this.state = 'rejected'
                this.result = reason
                while (this.onRejectedCallbacks.length) {
                    this.onRejectedCallbacks.shift()(this.result)
                }
            }
            then(onFulfilled, onRejected) {
                onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : val => val
                onRejected = typeof onRejected === 'function' ? onRejected : reason => { throw reason }
                let promise2 = new MyPromise((resolve, reject) => {
                    if (this.status === 'fulfilled') {
                        // Promise/A+ 2.2.4 -- setTimeout
                        setTimeout(() => {
                            try {
                                let x = onFulfilled(this.result)
                                // x 可能是一个 promise
                                resolvePromise(promise2, x, resolve, reject)
                            } catch (e) {
                                reject(e)
                            }
                        }, 0)
                    } else if (this.status = 'rejected') {
                        // Promise/A+ 2.2.3
                        setTimeout(() => {
                            try {
                                let x = onRejected(this.result)
                                resolvePromise(promise2, x, resolve, reject)
                            } catch (e) {
                                reject(e)
                            }
                        }, 0)
                    } else if (this.status === 'pending') {
                        this.onResolvedCallbacks.push(() => {
                            setTimeout(() => {
                                try {
                                    let x = onFulfilled(this.result);
                                    resolvePromise(promise2, x, resolve, reject)
                                } catch (e) {
                                    reject(e)
                                }
                            }m 0)
                        })
                        this.onRejectedCallbacks.push(() => {
                            setTimeout(() => {
                                try {
                                    let x = onRejected(this.result)
                                    resolvePromise(promise2, x, resolve, reject)
                                } catch (e) {
                                    reject(e)
                                }
                            }, 0)
                        })
                    }
                })
                return promise2
        }
        const resolvePromise = (promise2, x, resolve, reject) => {
            if (promise2 === x) {
                return reject(new TypeError('Chaining cycle detected for promise #<Promise>'))
            }
            // Promise/A+ 2.3.3.3.3 只能调用一次
            let called
            if ((typeof x === 'object' && x !== null) || typeof x === 'function') {
                try {
                    let then = x.then
                    // 如果 x 是一个 thenable 对象，支持链式调用
                    if (typeof then === 'function') {
                        then.call(x, y => {
                            if (called) return;
                            called = true
                            resolvePromise(promise2, x, resolve, reject)
                        }, r => {
                            if (called) return
                            called = true
                            reject(r)
                        })
                    } else {
                        resolve(x)
                    }
                } catch (e) {
                    if (called) return
                    called = true
                    reject(e)
                }
            } else {
                resolve(x)
            }
        }
    ```

- [X] 给定一系列的任务，这些任务可能有依赖关系，有依赖关系须相继执行，没有依赖关系则可以同时执行。写一个函数，计算完成给定所有任务需要的时间

    ```js
        const tasks = [
            { name: "task1", time: 1, dependency: "" },
            { name: "task2", time: 2, dependency: "" },
            { name: "task3", time: 3, dependency: "task1" },
            { name: "task4", time: 3, dependency: "task3" },
            { name: "task5", time: 4, dependency: "task2" }
        ]
        function getTime(tasks = []) {
            const cache = {}
            let maxTime = 0
            function getTaskTime(task) {
                let total = task.time
                if (task.dependency) {
                    if (cache[task.dependency]) {
                        total += cache[task.dependency]
                    } else {
                        total += getTaskTime(tasks.find(item => item.name === task.dependency))
                    }
                }
                cache[task.name] = total
                return total
            }
            tasks.forEach(getTaskTime)
            return Math.max(...Object.values(cache))
        }
    ```

- [ ] 15. 实现两个大整数加法

    ```js
    /**
     * @param {string} a
     * @param {string} b
     */
    function add(a, b) {
        let i = a.length
        let j = b.length

        let carry = 0; // 进位
        let result = '';

        while (i >= 0 || j >= 0) {
            let x = 0, y = 0;
            let sum
            if (i >= 0) {
                x = a[i] - '0'
                i--
            }
            if (j >= 0) {
                y = b[j] - '0'
                j--
            }
            sum = a + b + carry
            if (sum >= 10) {
                carry = 1
                sum -= 10
            } else {
                carry = 0
            }
            result = sum + result
        }
        if (carry) {
            result = carry + result
        }
        return result
    }
    ```
    
- [ ] 16. 手写 call、bind、apply

    ```js
    Function.prototype.myCall = function myCall(context, ...args) {
        context = typeof context === 'object' ? context : window
        const key = Symbol()
        context[key] = this
        const result = context[key](...args)
        delete context[key]
        return result
    }
    Function.prototype.myApply = function myApply(context, args) {
        context = typeof context === 'object' ? context : window
        const key = Symbol()
        context[key] = this
        const result = context[key](...args)
        delete context[key]
        return result
    }
    Function.prototype.myBind = function myBind(context) {
        context = typeof context === 'object' ? context : window
        return function(...args) {
            this.call(context, ...args)
        }
    }
    ```
    
- [ ] 17. 用 setTimeout 实现一个 setInterval, 要支持清理功能

    ```js
    function _setInterval(cb, schdule) {
        let timer = null;
        function run() {
            clearTimeout(timer)
            timer = setTimeout(() => {
                cb();
                run()
            }, delay)
        }
        run()
        return () => clearTimeout(timer)
    }
    ```
    
- [ ] 18. 实现一个发布订阅模式

    ```js
    class MyEvents {
        constructor() {
            this._events = Object.create(null)
        }
        on(type, cb) { // 相当于收集订阅者
            if (this._events[type]) {
                this._events[type].push(cb)
            } else {
                this._events[type] = [cb]
            }
        }
        emit(type, ...args) { // 相当于发布者
            if (this._events && this._events[type]) {
                this._events[type].forEach(cb => {
                    cb.call(this, ...args)
                })
            }
        }
        off(type, cb) { // 实现取消事件监听任务
            if (this._events && this._events[type]) {
                this._events[type] = this._events[type].filter(item => item !== cb && item !== cb.link)
            }
        }
        once(type, cb) { // 只执行一次回调
            let fn = function(...args) {
                cb.call(this, ...args)
                this.off(type, cb)
            }
            fn.link = callback
            this.on(type, fn)
        }
    }
    ```
    
- [ ] 19. 手写一个 flatten

    ```js
	    Array.prototype.flatten = function (num) {
	        if (Number(num) === 'NaN' || num <= 0) return
	        const arr = this
	        const res = []
	        arr.forEach(item => {
	            if (Array.isArray(item)) {
	                res = res.concat(item.flatten(num - 1))
	            } else {
	                res.push(item)
	            }
	        })
	        return res
	    }
    ```
    
- [ ]     	    
- [ ] 12. 我们的应用里有很多地方会使用「相对时间」来展示过去的时间。现在遇到的问题是这些相对时间是「静态」的。在页面静止一段时间后这些时间就「过时」了。请修改下面的代码让相对时间动起来（**每秒刷新一次**）。

    1. 功能实现
    2. 编程规范
    3. 性能提升
    4. 如果有大量的模块都需要刷新，有没有办法只用一个计时器实现？ 使用 React Context

- [ ] 13. 
    给一个句子 text = "this is a sentence it is not a good one and it is also bad"

    给一个数字 n = 5

    给一个数字 m = 2

    输出一个单词长度为 n 的句子

    要求：

    输出的前 m 个单词在 text 里随机选择一个连续的单词组合

    下一个单词是当前输出的末尾 m 个单词在 text 里后一个单词的随机选择（比如现在输出的末尾是 it is，那么下一个单词就是 [not, also] 里随机选择一个）
    
    ```js
        function solution(text, n, m) {
            const hash = new Map()
            const textArr = text.split(' ')
            for (let i = 0; i <= textArr.length - m; i++) {
                const word = textArr.slice(i, i + m).join(' ');
                const next_word = i < textArr.length - m ? textArr[i+m] : textArr[0]
                if (hash.has(word)) {
                    hash.get(word).push(next_word)
                } else {
                    hash.set(word, [next_word])
                }
            }
            const randomWord = function(arr) {
                return arr[Math.floor(Math.random() * arr.length)]
            }
            let curWord = randomWord(Array.from(hash.keys()))
            let res = curWord.split(' ')
            let i = 1, arr = hash.get(curWord)
            while (i < n - m + 1) {
                const word = randomWord(arr)
                res.push(word)
                curWord = res.slice(i, i + m).join(' ')
                arr = hash.get(curWord) || []
                i++
            }
            return res.join(' ')
        }
    ```
    
- [ ] 14. 

    Token card games
    Given card with cost in terms of tokens. For eg to buy some Card A, you need 3 Blue tokens and 2 Green tokens. Tokens can be of Red, Green, Blue, Black or White color.
    Now there is player who is holding some tokens. For eg player has 4 Blue tokens and 2 Green tokens, then player can buy above Card A. Lets say if player only has 2 Blue tokens and 2 Green tokens, then player can not buy Card A above as player is short of 1 Blue token.
    Write a method that returns true if player can buy the card or false otherwise.
    More examples :
    Cost of Card : 2 White, 1 Black and 4 Blue.
    If Player has : 2 White, 2 Black and 4 Blue, method will return true
    If Player has : 2 White, 2 Green and 4 Blue, method will return false
    More examples :
    Cost of Card : 2 White, 1 Black and 4 Blue. From 1point 3acres bbs
    If Player has : 2 White, 2 Black and 4 Blue, method will return true
    If Player has : 2 White, 2 Green and 4 Blue, method will return false
    1. Implement canPurchase and purchase
    2. Discount with card owned
    (比如手里有三张 Red Card，下一张待购买的卡片 cost 需要 N 个 Red Money，实际购买时 只需要支付 N-3 个 Red Money 就行)
    cost: {"Red":4}
    player:{"Red":7,"Bule":5}
    purchase()
    player:{"Red":3,"Bule":5}
    playerCard:{"Red":1}
    purchase()
    player:{"Red":0,"Bule":5}
    playerCard:{"Red":2}
    3. Gold color
    Money 增加一种 Gold color，万能色，可以在买卡的时候冲抵任何一种颜色。比如 下一张待购买的卡片 cost 需要 N 个 Red Money。手里只有 N-1 个 Red Money，但是有超 过一个 Gold Money，那也买得起
    
    ```js
    class TokenCardPlayer {
        constructor(cards, n = 0) {
            this.cards = cards
            this.ownCard = {}
        }
        getCardWithColor(color) {
            return this.ownCard[color] || 0
        }
        addPlayerCard(color, n) {
            this.ownCard[color] = (this.ownCard[color] || 0) + n
        }
        calRemained(costOfCard) {
            const remain_cards = Object.assign({}, this.cards)
            let remain_gold_color = this.goldColor
            let canPurchase = true
            for (let [color, cost] of Object.entries(costOfCard)) {
                const ac_cost = cost - this.getCardWithColor(color)
                remain_cards[color] -= ac_cost
                if (remain_cards[color] < 0) {
                    if (remain_cards[color] + remain_gold_color >= 0) {
                        remain_cards[color] = 0
                        remain_gold_color = remain_gold_color + remain_cards[color]
                    } else {
                        canPurchase = false
                    }
                }
            }
            return { remain_cards, remain_gold_color, canPurchase }
        }
        canPurchase(costOfCard) {
            const discountCard = Object.assign({}, this.ownCards)
            return Object.entries(costOfCard).every(([color, cost]) => {
                const remain = this.cards[color] + discountCard[color]
                if (remain >= cost) return true
                if (discountCard.gold > cost - remain) {
                    discountCard['gold'] -= cost - remain
                } else {
                    return false-
                }
            })
        }
        purchase(costOfCard, earnedCard) {
            if (!this.canPurchase(costOfCard)) return false
            const cards = this.cards
            let goldColor = this.goldColor
            for (let [color, cost] of Object.entries(costOfCard)) {
                const ac_cost = cost - this.getCardWithColor(color)
                let remain = cards[color] - ac_cost
                if (remain < 0) {
                    cards[color] = 0;
                    goldColor -= remain
                } else {
                    cards[color] -= ac_cost
                }
            }

            Object.entries(earnedCard).forEach(([color, n]) => this.addPlayerCard(color, n))
            return true
        }
    }
    ```
    

# 网络
## HTTP 请求的格式是怎么样的？请求头之间是怎么隔开的？
- 请求行：包含方法、URL、协议版本
- 请求头：请求报头允许客户端向服务器传递请求的附加信息和客户端自身的信息。常见的请求报头有：
  - Accept：浏览器可以处理的内容类型。
  - Accept-Charset：浏览器可以显示的字符集。
  - Accept-language：浏览器使用的语言。
  - Content-Encoding:
    - gzip：表示采用 Lempel-Ziv coding (LZ77)压缩算法，以及 32 位 CRC 校验的编码方式
    - compress：采用 Lempel-Ziv-Welch (LZW) 压缩算法
    - deflate：采用 zlib
  - Accept-Encoding：浏览器可以处理的压缩编码类型。
  - Connection：浏览器与服务器的连接类型。(keep-alive开启长连接)
  - Content-Type：浏览器提交的内容类型（如 `application/x-www-formurlencoded` 为提交表单时使用的)。
  - Cookie：页面中设置的Cookie。
  - Host：发送请求的页面所在的域。
  - Referer：发送请求的页面URI。
  - User-Agent：浏览器的用户代理字符串。
- 空行
- 请求体
    当使用POST, PUT等方法时，通常需要客户端向服务器传递数据，这些数据就存储在请求正文中。在请求报头中有一些与请求正文相关的信息，例如现在的web应用通常采用REST架构，请求的数据格式一般为json。这时就需要设置Content-Type: application/json。

## HTTPS 连接过程；客户端怎么知道服务端发送的证书是可信的？
### 数字证书和 CA 机构
在说校验数字证书是否可信的过程中，我们先来看看数字证书是什么，一个数字证书通常包含了：

- 公钥；
- 持有者信息；
- 证书认证机构（CA）的信息；
- CA 对这份文件的数字签名及使用的算法；
- 证书有效期；
- 还有一些其他额外的信息；

那数字证书的作用，是用来认证公钥持有者的身份，以防止第三方进行冒充。说简单些，证书就是用来告诉客户端，该服务端是否合法，因为只有证书合法，才代表服务端身份是可信的。

我们用证书来认证公钥持有者的身份，那证书又是怎么来的？又该怎么认证证书呢？

为了让服务端的公钥被大家信任，服务端的证书都是由 CA(**Certificate Authority，证书认证机构**) 签名的，CA 就是网络世界里的公证中心，由它来给各个公钥签名，信任的一方签发的证书，那必然证书也是被信任的。

之所以要签名，是因为签名的作用可以避免中间人在获取证书时对证书内容的篡改。

### 数字证书签发和验证流程

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b43119a2-ed04-49dc-b528-45ddcac35c9b/Untitled.png)

**CA 签发证书的过程**：

- 首先 CA 会把持有者的**公钥、用途、颁发者、有效时间**等信息打成一个包，然后对这些信息进行 Hash 计算，得到一个 hash 值；
- 然后 CA 会使用自己的私钥将该 Hash 值加密，生成 Certificate Signature，也就是 CA 对证书做了签名；
- 最后将 Certificate Signature 添加在文件证书上，形成数字证书；

**客户端校验服务端的数字证书的过程**，如上图右边部分：

- 首先客户端会使用同样的 Hash 算法获取该证书的 Hash 值 H1；
- 通常浏览器和操作系统中集成了 CA 的**公钥信息**，浏览器收到证书后可以使用 CA 的公钥解密 Certificate Signature 内容，得到一个 Hash 值 H2；
- 最后比较 H1 和 H2，如果值相同，则为可信赖的证书，否则认为证书不可信。
## HTTPS 和 HTTP 的区别？可以说说 SSL/TLS 的过程吗？
### TLS 握手过程

HTTP 由于是明文传输，所谓的明文，就是说客户端与服务端通信的信息都是肉眼可见的，随意使用一个抓包工具都可以截获通信的内容。

所以安全上存在以下三个风险：

- **窃听风险**，比如通信链路上可以获取通信内容；
- **篡改风险**，比如强制植入垃圾广告，视觉污染；
- **冒充风险**，比如冒充淘宝网站；

TLS 协议是如何解决 HTTP 的风险的？

- **信息加密**：HTTP 交互信息是被加密的，第三方就无法窃取；
- **校验机制**：校验信息传输过程中是否有被第三方篡改过，如果被篡改过，则会有警告提示；
- **身份证书**：证明淘宝是真淘宝；

可见，有了 TLS 协议，能保证 HTTP 通信是安全的了，那么在进行 HTTP 通信前，需要先进行 TLS 握手。TLS 的握手过程如下：

上图简要概述了 TLS 的握手过程，其中每一个[框]都是一个记录（record），记录是 TLS 收发数据的基本单位，类似于 TCP 里的 segment。多个记录可以组合成一个 TCP 包发送，所以通常经过**四个信息**就可以完成 TLS 握手，也就是需要 2 个 RTT 的时延，然后就可以在安全的通信环境里发送 HTTP 报文，实现 HTTPS 协议。

所以可以发现，HTTPS 是应用层协议，需要先完成 TCP 连接建立，然后 TLS 握手过程后，才能建立通信安全的连接。

### RSA 握手过程

传统的 TLS 握手基本都是使用 RSA 算法来实现密钥交换的，在将 TLS 正数部署服务器时，正数文件中包含一对公私钥，其中公钥会在 TLS 握手阶段传递给客户端，私钥则一直留在服务端，一直要确保私钥不能背窃取。

在 RSA 密钥协商算法中，**客户端会生成随机密钥**，并使用服务端的公钥加密后再传给服务端。根据非对称加密算法，公钥加密的消息仅能通过私钥解密，这样服务端解密后，双方就得到了相同的密钥，再用它加密应用消息。

用 Wireshark 工具抓了用 RSA 密钥交换的 TLS 握手过程，你可以从下面看到，一共经历了四次握手：

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d0839491-365a-4b32-a063-c31be7de785d/Untitled.png)

对应 Wireshark 的抓包，可以从下图很清晰地看到该过程：

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/2068d876-3d3a-442e-a774-86e714f58188/Untitled.png)

那么，接下来针对每一个 TLS 握手做进一步的介绍。

#### TLS 第一次握手

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ebf72467-c534-4d7f-abce-0f450c1f9931/Untitled.png)

客户端首先会发一个 【Client Hello】消息，发起 TLS 连接。

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/49c91e2e-1a75-426b-a40d-79d3a7c90bca/Untitled.png)

消息里面有客户端使用的 **TLS 版本号**、**支持的密码套件列表**以及生成的**随机数（*Client Random*）**，这个随机数会被服务端保留，它是生成对称加密密钥的材料之一。

#### TLS 第二次握手

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/baf59746-dc5f-42f4-bb93-35aaaf0c8fd9/Untitled.png)

当服务端收到客户端的 [Client Hello] 消息后，会确认 TLS 版本号是否支持，和从密码套件列表中选择一个密码套件，以及生成**随机数（*Server Random*）**。

接着返回 **[Server Hello]** 消息，消息里面有服务器确认的 **TLS 版本**、**随机数（Server Random）**，然后从客户端的密码套件列表中选择一个合适的**密码套件**。

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b655ab58-637e-41ad-b503-d32be595632d/Untitled.png)

可以看到，服务端选择的密码套件是“Cipher Suite: TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384“。

> 密码套件是有固定格式和规范的。基本形式是 [**密钥交换算法 + 签名算法 + 对称加密算法 + 摘要算法**]，一般 WITH 单词前面有两个单词，第一个单词是约定密钥交换算法，第二个单词是约定证书的验证算法，即签名算法。上面的密码套件的意思是：
- 密钥交换算法是 ECDHE 算法；
- 签名算法是 RSA 算法；
- 握手后通信使用 AES 对称算法，密钥长度 256位，分组模式是 GCM；
- 摘要算法 SHA384 用于消息认证和产生随机数；
> 

就前面客户端和服务器相互打招呼（**Client/Server Hello**）的过程，客户端和服务器已经确认了 TLS 版本和使用的密码套件，而且把各自生成的随机数传递给了对方。

这两个随机数是后续作为生成 **会话密钥** 的条件，所谓的会话密钥就是数据传输时，所使用的对称加密密钥。

然后，服务端为了证明自己的身份，会发送 **[Certificate]** 给客户端，这个消息里含有**数字证书**。

随后，服务端发了 **[Server Key Change]** 和 **[Server Hello Done]** 消息，后者的目的是告诉客户端，我已经把该给你的东西都给你了，本次打招呼完毕。

#### 客户端验证证书

客户端拿到了服务端的数字证书后，要怎么校验该数字证书是真实有效的呢？

##### 数字证书和 CA 机构

在说校验数字证书是否可信的过程中，我们先来看看数字证书是什么，一个数字证书通常包含了：

- 公钥；
- 持有者信息；
- 证书认证机构（CA）的信息；
- CA 对这份文件的数字签名及使用的算法；
- 证书有效期；
- 还有一些其他额外的信息；

那数字证书的作用，是用来认证公钥持有者的身份，以防止第三方进行冒充。说简单些，证书就是用来告诉客户端，该服务端是否合法，因为只有证书合法，才代表服务端身份是可信的。

我们用证书来认证公钥持有者的身份，那证书又是怎么来的？又该怎么认证证书呢？

为了让服务端的公钥被大家信任，服务端的证书都是由 CA(**Certificate Authority，证书认证机构**) 签名的，CA 就是网络世界里的公证中心，由它来给各个公钥签名，信任的一方签发的证书，那必然证书也是被信任的。

之所以要签名，是因为签名的作用可以避免中间人在获取证书时对证书内容的篡改。

##### 数字证书签发和验证流程

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b43119a2-ed04-49dc-b528-45ddcac35c9b/Untitled.png)

**CA 签发证书的过程**，如上图左边部分：

- 首先 CA 会把持有者的**公钥、用途、颁发者、有效时间**等信息打成一个包，然后对这些信息进行 Hash 计算，得到一个 hash 值；
- 然后 CA 会使用自己的私钥将该 Hash 值加密，生成 Certificate Signature，也就是 CA 对证书做了签名；
- 最后将 Certificate Signature 添加在文件证书上，形成数字证书；

**客户端校验服务端的数字证书的过程**，如上图右边部分：

- 首先客户端会使用同样的 Hash 算法获取该证书的 Hash 值 H1；
- 通常浏览器和操作系统中集成了 CA 的**公钥信息**，浏览器收到证书后可以使用 CA 的公钥解密 Certificate Signature 内容，得到一个 Hash 值 H2；
- 最后比较 H1 和 H2，如果值相同，则为可信赖的证书，否则认为证书不可信。

#### TLS 第三次握手

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b8b48d13-8ae0-4fb4-becd-1d168c2cc701/Untitled.png)

客户端验证完证书后，认为可信则继续往下走。接着，客户端就会生成一个新的**随机数(*pre-master*)**，用服务端的 RSA 公钥（从证书中获取的）加密该随机数，通过 [**Change Cipher Key Exchange**] 消息传递给服务端。下面分别是 ECDHE 和 RSA 两种不同的算法的信息。（本文主要讲的是 RSA 的握手过程）

ECDHE:

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1659ca63-8d8f-448e-b954-996a5c70755f/Untitled.png)

RSA:

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/2185badf-4349-4ba7-978e-2fb24938432d/Untitled.png)

服务端收到后，用 RSA 私钥解密，得到客户端发来的**随机数(*pre-master*)**。

至此，客户端和服务端双方都共享了三个随机数，分别是 **Client Random, Server Random, pre-master**。

于是，双方根据已经得到的三个随机数，生成**会话密钥（Master Secret）**，它是对称密钥，用于对后续的 HTTP 请求/响应的数据加解密。

生成会话密钥后，客户端发一个 [**Change Cipher Spec**]，告诉服务端开始使用加密方式发送消息。

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a7200d60-0f3c-4d44-b78b-3e73e4f93858/Untitled.png)

然后，客户端再发一个 [**Encrypted Handshake Message** (Finished)] 消息，把之前所有发送的数据做个摘要，再用**会话密钥（Master Secret）**加密一下，让服务器做个验证，**验证加密通信是否可用**和**之前握手信息是否有被中途篡改过**。

可以发现，[**Change Cipher Spec**] 之前传输的 TLS 握手数据都是明文，之后都是对称密钥加密的密文。

#### TLS 第四次握手

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/553b093d-b34f-4ed5-96ba-dac00a0eca7b/Untitled.png)

服务器也是同样的操作，发 [**Change Cipher Spec**] 和 [**Encrypted Handshake Message**] 消息，如果双方都验证加密和解密没问题，那么握手正式完成。

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e8cd09b8-826d-4a34-b81c-b63a103446ed/Untitled.png)

最后就用 [**会话密钥**] 加解密 HTTP 请求和响应了。

## get 方法和 post 方法的区别?
- 幂等性：get 是幂等的，不管请求多少次，根据服务器数据的实际情况返回数据；POST 是非幂等的，每次请求都会修改数据库。
- 后退按钮或刷新：与幂等性相关，get 方法是无害的，post 方法是有害的;
- 缓存：get 方法能被缓存，POST 不能；
- 数据大小限制：GET 方法通过 URL 传参数时，url 的长度是受限制的，(URL 的最大长度是 2048)；而 POST 方法的数据大小是没有限制的，但是服务器端可以限制允许接收的大小；
- 安全性：GET 安全性较差，请求参数暴露在 url 中；而 POST 相对较安全
- 编码类型：GET 的编码类型是 application/x-www-form-urlencoded，而 POST 的编码类型是 application/x-www-form-urlencoded 或 application/form-data。为二进制数据使用多重编码。

## 为什么会有跨域问题，怎么解决跨域问题？

### 1. 为什么会有跨域问题？

同源策略：即通信只能在***相同域名、相同端口和相同协议***的前提下完成。访问超出这些限制之外的资源会导致安全错误，除非使用了正式的跨域方案，这个方案叫做跨域资源共享CORS。如果缺少了同源策略，浏览器很容易受到一些恶意行为，例如 XSS、CSRF 等攻击。

同源策略限制的内容有：

- Cookie、LocalStorage、IndexedDB 等存储性内容
- DOM节点
- AJAX 请求发送后，结果被浏览器拦截

但有三个标签时允许跨域加载资源的：

- `<img src="xxx">`
- `<link href="xxx">`
- `<script src="xxx">`

跨域并不是请求发不出去，请求能发出去，并且服务器端能收到请求并正常返回结果，只是结果被浏览器拦截了，浏览器会根据响应头的 `Access-Control-Allow-Origin` 字段的值来判断是否有权限获取数据。这就解释了Ajax为什么不能跨域的原因，也说明了跨域需要解决的问题就是：**如何从客户端拿到返回的数据？**

怎么限制标签中 src/href 的跨域请求？

- 设置标签的 `crossOrigin` 属性值为 `use-credential` ;
- 设置 CSP 白名单，限制页面中的各种资源的请求来源；可以服务器响应头中设置，也可以在前端 HTML 的 `meta` 标签中设置比如
    
    `<meta http-equiv="Content-Security-Policy" content="img-src: XXX" />`
    

### 2. 怎么解决跨域问题？

#### (1) JSONP

**JSONP** 请求本质上是利用 `script` 标签没有跨域限制的漏洞，网页可以得到从其他来源动态产生的 JSON 数据。JSONP请求一定需要对方的服务器做支持才可以。

JSONP和AJAX相比，AJAX属于同源策略，JSONP属于非同源策略；

优点：简单易用、兼容性好、可用于解决主流浏览器的跨域数据访问的问题。

缺点：

- 如果这个域不可信，可能会遭受XSS攻击；
- 仅支持GET方法；
- 不好确定JSONP请求是否失败；

> 虽然HTML5规定了 `<script>` 元素的onerror时间处理程序，但还没有被任何浏览器实现。为此，开发者经常使用计时器来决定是否放弃等待响应，这种方式并不准确。
> 

```jsx
// jsonp 封装
const jsonp = ({ url, params, callbackName = 'cb' }) => {
    const generateURL = () => {
        let dataStr = "";
        for (let key in params) {
            dataStr += `${key}=${params[key]}&`;
        }
        dataStr += `callback=${callbackName}`;
        return `${url}?${dataStr}`;
    };
    return new Promise((resolve, reject) => {
        // 初始化回调函数名称
        callbackKey = callbackName + Math.random().toString().replace(".", "");
        let scriptEle = document.createElement("script");
        scriptEle.src = generateURL();
        document.body.appendChild(scriptEle);
        //绑定到 window 上，为了后面调用
        window[callbackKey] = data => {
            resolve(data);
            // script 执行完了，成为无用元素，需要清除
            document.body.removeChild(scriptEle);
        }
    });
}
jsonp({
    url: "http://127.0.0.1:8000/",
    params: {
        name: "Joey",
        age: "18"
    },
    callbackName: "getData",
}).then(response => JSON.parse(response)).then(data => {
    console.log(data);
});
```

#### (2) CORS - Cross Origin Resource Sharing

**CORS**需要浏览器和后端同时支持。

浏览器会自动进行 CORS 通信，实现 CORS 通信的关键是后端。只要后端实现了 CORS，就实现了跨域。

服务端设置 `Access-Control-Allow-Origin` 就可以开启 CORS。该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。

虽然设置 CORS 和前端没什么关系，但是通过这种方式解决跨域问题的话，会在发送请求的时候出现两种情况：**简单请求**和**非简单请求**。

**简单请求**

简单请求需要满足下列条件（[更多上MDN查阅](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS)）：除此之外都是非简单请求

1. 请求方法是 **GET、HEAD 和 POST** 之一
2. 只包含被用户代理自动设置的首部字段（例如 `Connection`，`User-Agent`）和在 Fetch 规范中定义的对 CORS 安全的首部字段集合。该集合为：
    - `Accept`
    - `Accept-Language`
    - `Content-Language`
    - `DPR`
    - `Downlink`
    - `Save-Data`
    - `Viewport-Width`
    - `Width`
    - `Content-type`: 该值仅限于下列三者之一
        - `text/plain`
        - `mutipart/form-data`
        - `application/x-www-form-urlencoded`

**非简单请求**

1. 预检请求

非简单请求在进行真正的请求之前，浏览器会使用 OPTIONS 方法发送一个**预检请求**，OPTIONS 是 `HTTP/1.1` 协定中定义的方法，用以从服务器获取更多信息。通过该请求来知道服务端是否允许跨域请求。还包含以下头部：

- Origin：与简单请求相同。
- Access-Control-Request-Method：请求使用的方法。
- Access-Control-Request-Headers：（可选）要使用逗号分隔的自定义头部列表。

请求发送后，服务器可以确定是否允许这种类型的请求。服务器会通过在响应中发送以下头部与浏览器沟通这些信息。

- `Access-Control-Allow-Origin`：与简单请求相同。
- `Access-Control-Allow-Methods`：允许的方法（逗号分隔的列表）。
- `Access-Control-Allow-Headers`：服务器允许的头部（逗号分隔的列表）。
- `Access-Control-Max-Age`：缓存预检请求的秒数。
1. 凭据请求

默认情况下，跨域请求不提供凭据（cookie、HTTP 认证和客户端 SSL 证书）。可以通过将 `withCredentials` 属性设置为true来表明请求会发送凭据。如果服务器允许带凭据的请求，那么可以在响应中包含如下HTTP头部：

`Access-Control-Allow-Credentials: true`

如果发送了凭据请求而服务器返回的响应中没有这个头部，则浏览器不会把响应交给 JavaScript（responseText 是空字符串，status是0，onerror()被调用）。服务器也可以在预检请求的响应中发送这个头部，以表明这个源允许发送凭据请求。

#### (3) postMessage

postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题：

- 页面和其打开的新窗口的数据传递
- 多窗口之间的消息传递
- 页面与嵌套的iframe消息传递
- 上面三个场景的跨域数据传递

**postMessage**允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递。

**syntax：`otherWindow.postMessage(message, targetOrigin, [transfer]);`**

- `otherWindow`: 其他窗口的一个引用，比如iframe的contentWindow属性、执行 `window.open` 返回的窗口对象、或者是命名过或数值索引的`window.frames`。
- `message`: 将要发送到其他 window 的数据。它将会被**结构化克隆算法**序列化。这意味着可以不受什么限制的将数据对象安全的传送给目标窗口而无需自己序列化。
- `targetOrigin`: 通过窗口的origin属性来指定哪些窗口能接收到消息事件，其值可以实字符串"*"（表示无限制）或者一个URI。在发送消息的时候，如果目标窗口的协议、主机地址或端口这三者的任意一项不匹配targetOrigin提供的值，那么消息就不会被发送；只有三者完全匹配，消息才会被发送。
- `transfer`（可选）: 是一串和message同时传递的 `Transferable` 对象。这些对象的所有权将被转移到给消息的接收方，而发送一方将不再保有所有权。

#### (4) Nginx Proxy 反向代理

使用 nginx 反向代理实现跨域，是最简单的跨域方式。只需要修改 nginx 的配置即可解决跨域问题，支持所有浏览器，支持 session，不需要修改任何代码，并且不会影响服务器性能。

实现思路：通过 nginx 配置一个代理服务器（域名与 domain1 相同，端口户同）作为跳板机，反向代理访问 domain2 的接口，并且可以顺便修改 cookie 中 domain 信息，方便当前域 cookie 的写入，实现跨域请求。

#### (5) Node 中间件代理 （两次跨域）

实现原理：同源策略是浏览器需要遵循的标准，如果服务器向服务器请求就无需遵循同源策略。

Node 作为代理服务器，需要做一下几个步骤：

1. 接收客户端的请求
2. 将请求转发给服务器
3. 拿到服务器的响应数据
4. 将响应转发给客户端

需要注意的是，浏览器向代理服务器发送请求，也遵循同源策略

#### (6) Web Socket

## TCP 重传机制、滑动窗口、流量控制和拥塞控制
- RTT: 数据发送时刻-接收到确认的时刻的插值，也就是包的往返时间
- RTO: 超时重传时间
### 重传机制

TCP 实现可靠传输的方式之一，就是通过序列号与确认应答。

1. 超时重传

在发送数据时，设定一个定时器，当超过指定的时间后，没有收到对方的 ACK 确认应答报文，就会重发该数据。
TCP 会在以下两种情况发生超时重传：
- 数据包丢失
- 确认应答丢失

超时重传的问题是超时周期可能相对较长。于是就可以用**快速重传**机制来解决超时重传的时间等待。
2. 快速重传

快速重传不以时间为驱动，而是以数据驱动重传。当发生数据包丢失的时候，后续数据包的 Ack 会返回丢失包的 Ack，当请求发起方收到三个相同的 Ack 的值，就知道丢包了，就会在定时器过期之前，重传丢失的包，最后接收方返回最后的包的 Ack。

快速重传的工作方式是当收到三个相同的 ACK 报文时，会在定时器过期之前，重传丢失的报文段。

快速重传机制只解决了一个问题，就是超时时间的问题，但是它依然面临着另外一个问题。就是重传的时候，是重传之前的一个，还是重传所有的问题。

根据 TCP 不同的实现，以上两种情况都是有可能的。可见，这是一把双刃剑。为了解决不知道该重传哪些 TCP 报文，于是就有 Sack 方法。
3. SACK - Selective Ack

这种方式需要在 TCP 头部的 option 字段加一个 SACK 的东西，它可以将缓存的地图发送给发送方，这样发送方就可以知道哪些数据收到了，哪些没收到，就可以只重传丢失的数据。
4. D-Sack

主要使用了 SACK 来告诉发送方有哪些数据被重复接收了。

### 滑动窗口

TCP 头里有一个字段叫 Window, 也就是窗口大小。

这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。

所以，通常窗口的大小是由接收方的窗口大小来决定的。
发送方发送的数据不能超过接收方的窗口大小，否则接收方就无法正常接收到数据。

1. 发送窗口
2. 接收窗口


### 流量控制

发送方不能无脑的发数据给接收方，要考虑接收方处理能力。如果一直无脑的发数据给对方，但对方处理不过来，那么就会导致触发重传机制，从而导致网络流量的浪费。

为了解决这种现象发生，TCP 提供一种机制可以让发送方根据接收方的实际接收能力控制发送的数据量，这就是所谓的流量控制。

### 拥塞控制
1. 慢启动
2. 拥塞避免
3. 拥塞发生
4. 快速回复

## 服务端挂了，客户端的 TCP 连接还在吗？
如果服务端挂了指的是：

- *服务端进程崩溃*，服务端的进程在发生崩溃的时候，内核会发送 FIN 报文，与客户端进行四次挥手。
- *服务端主机宕机*，那么是不会发生四次挥手的，具体后续会发生什么？还要看客户端会不会发送数据
    - 如果客户端会发送数据，由于服务端已经不存在，客户端的数据报文会**超时重传**，当重传总间隔时长达到一定阈值后，会断开 TCP 连接；
    - 如果客户端一直不发送数据，再看客户端有没有开启 TCP **keepalive** 机制
    - 如果有开启，客户端在一段时间后没有进行数据交互时，会触发 TCP keepalive 机制，探测对方是否存在，如果探测到对方已经消亡，则会断开自身的 TCP 连接；
    - 如果没有开启，客户端的 TCP 连接会一直存在，并且一直保持 ESTABLISHED 状态。

## 为什么握手要三次，挥手却要四次呢？

那是因为握手的时候并没有数据传输，所以服务端的 SYN 和 ACK 报文可以一起发送，但是挥手的时候**有数据在传输**，所以 ACK 和 FIN 报文不能同时发送，需要分两步，所以会比握手多一步。

### 为什么客户端在第四次挥手后还会等待 2MSL？

等待 2MSL 是因为保证服务端接收到了 ACK 报文，因为网络是复杂的，很有可能 ACK 报文丢失了，如果服务端没接收到 ACK 报文的话，会重新发送 FIN 报文，只有当客户端等待了 2MSL 都没有收到重发的 FIN 报文时就表示服务端是正常收到了 ACK 报文，那么这个时候客户端就可以关闭了。
## UDP 和 TCP 的区别
TCP 协议是**面向连接**的**可靠的**传输层协议，它是**面向字节流**的，它有**拥塞控制**，**失败重传**等机制保证可靠传输，它只能**点对点全双工通信**。

UDP 协议是**无连接**的**不可靠**的传输层协议，它是**面向报文**的，**支持一对一、一对多、多对一和多对多的交互通信**。

# Node
## Node事件循环

### 1. 浏览器中的事件循环
Javascript 代码的执行过程中，除了依靠函数调用栈来搞定函数的执行顺序外，还依靠任务队列（task queue) 来搞定另外一些代码的执行。整个执行过程，我们称**事件循环**过程。一个线程中，**事件循环是唯一的**，但是**任务队列可以拥有多个**。任务队列又分为 macro-task（宏任务）与 micro-task（微任务），在最新标准中，它们分别被称为 task 与 jobs。

macro-task 大概包括：

- script（整体代码)
- setTimeout
- setInterval
- setImmediate
- I/O
- UI render

micro-task 大概包括：

- process.nextTick
- Promise
- Async/Await(实际就是promise)
- MutationOberver(HTML5新特性)

总的结论就是，执行宏任务，然后执行该宏任务产生的微任务，若微任务在执行过程中产生了新的微任务，则继续执行微任务，微任务执行完毕后，再回到宏任务中进行下一轮循环。

### 关于 async/await 的执行顺序

这个问题涉及到 await 语法糖和 Promise 之间的转换，需要一些篇幅才能够讲明白，所以另起了[一篇文章](https://github.com/JA-Coding-J/Blog_FL/issues/2)展开说明。

### 2. Node 中的事件循环

### macro-task

- setTimeout
- setInterval
- setImmediate
- script(整体代码)
- I/O 操作等

### micro-task

- new Promise().then()/Promise.resolve()等
- process.nextTick(与普通微任务有区别，在微任务队列执行之前执行)

Node.js 运行机制如下：

1. V8 引擎解析 JavaScript 脚本
2. 解析后的代码，调用 Node API
3. libuv 库负责 Node API 的执行。它将不同的任务分配给不同的线程，形成一个 Event Loop（事件循环），以异步的方式将任务的执行结果返回给 V8 引擎。
4. V8 引擎再将结果返回给用户。

### node 事件循环简化图

```
    ┌───────────────────────────┐
┌─>│           timers          │
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
│  │     pending callbacks     │
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
│  │       idle, prepare       │
│  └─────────────┬─────────────┘      ┌───────────────┐
│  ┌─────────────┴─────────────┐      │   incoming:   │
│  │           poll            │<─────┤  connections, │
│  └─────────────┬─────────────┘      │   data, etc.  │
│  ┌─────────────┴─────────────┐      └───────────────┘
│  │           check           │
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
└──┤      close callbacks      │
    └───────────────────────────┘
```

图中的每个框被称为事件循环机制的一个阶段，每个阶段都有一个 FIFO 队列来执行回调。虽然每个阶段都是特殊的，但通常情况下，当事件循环进入给定的阶段时，它将执行特定于该阶段的任何操作，然后执行该阶段队列中的回调，直到队列用尽或最大回调数已执行。当该队列已用尽或达到回调限制，事件循环将移动到下一阶段。

### 阶段概述

从上图中，大概看出 node 中的事件循环的顺序：

外部输入数据 → 轮询阶段(poll) → 检查阶段(check) → 关闭事件回调阶段(close callback) → 定时器检测阶段(timers) → I/O事件回调阶段(I/O callbacks) → 闲置阶段(idle, prepare) → 轮询阶段(poll)（按照该顺序反复运行）

- 定时器检测阶段(timers): 本阶段执行 timer 的回调，即 setTimeout、setInterval 里面的回调函数。
- I/O事件回调阶段(pending callbacks): 执行延迟到下一个循环迭代的I/O回调，即上一轮循环中未被执行的一些I/O回调
- 闲置阶段(idle, prepare): 仅系统内部使用。
- 轮询阶段(poll): 检索新的I/O事件；执行与I/O相关的回调（几乎所有情况下，除了关闭的回调函数，那些由计时器和 setImmediate() 调度的之外），其余情况node将在适当的时候在此阻塞。
- 检查阶段(check): setImmediate() 回调函数在这里执行
- 关闭事件回调阶段(close callback): 一些关闭的回调函数，如: socket.on(‘close’,…)。

### 三大重点阶段

日常开发中的绝大部分异步任务都是在 poll、check、timers 这3个阶段处理的。

### timers

timers 阶段会执行 setTimeout 和 setInterval 回调，并且是由 poll 阶段控制的。同样的，在 Node 中定时器指定的事件也不是准确时间，只能是尽快执行。Operating System scheduling or the running of other callbacks may delay them.

### poll

poll 是一个至关重要的阶段，poll 阶段的执行逻辑如下：

![Node EventLoop - poll](https://github.com/JA-Coding-J/Blog_FL/blob/master/images/setTimeout.png)

它有两个重要的功能：

1. 计算应该阻塞和轮询 I/O 的时间。（计算 `timeout`）
2. 处理**轮询**队列里的时间

当事件循环进入 **轮询** 阶段且 *没有被调度的计时器时* ，将发生以下两种情况之一：

- 如果 poll 队列不为空，会遍历回调队列并**同步执行**，直到队列为空或者达到系统限制
- 如果 poll 队列为空，会有两件事发生
    - 如果有 setImmediate 回调需要执行，poll 阶段会停止并且进入到 check 阶段执行回调
    - 如果没有 setImmediate 回调需要执行，会等待回调被加入到队列中并立即执行回调，这里同样会有个超时时间设置防止一直等待下去，一段时间后自动进入 check 阶段。

> To prevent the **poll** phase from starving the event loop, [libuv](https://libuv.org/) (the C library that implements the Node.js event loop and all of the asynchronous behaviors of the platform) also has a ***hard maximum*** (system dependent) before it stops polling for more events.
> 

一旦 **轮询** 队列（指其他阶段的观察者都没有可执行的事件）为空，事件循环将检查 *已达到时间阈值的计时器*。如果一个或多个计时器已准备就绪，则事件循环将绕回（意思是其他队列为空了，那么下两个 `tick` 也可以直接跳过，进入下一个 loop）计时器阶段以执行这些计时器的回调。

### check

check 阶段。直接执行 setImmediate 的回调

### process.nextTick

process.nextTick 是一个独立于 eventLoop 的任务队列。

在每一个 eventLoop 阶段完成后会去检查 nextTick 队列，如果里面有任务，会让这部分任务优先于微任务执行。

```jsx
setImmediate(() => {
console.log('timeout1')
Promise.resolve().then(() =>console.log('promise resolve'))
process.nextTick(() =>console.log('next tick1'))
});
setImmediate(() => {
console.log('timeout2')
process.nextTick(() =>console.log('next tick2'))
});
setImmediate(() =>console.log('timeout3'));
setImmediate(() =>console.log('timeout4'));
```

- 在 node 11 之前，会先执行 check 阶段队列中的所有任务（即 setImmediate），再执行由 nextTick 产生的微任务（如果有），最后才执行其他微任务，因此输出为
    
```jsx
// timeout1 => timeout2 => timeout3 => timeout4 => next tick1 => next tick2 => promise resolve
```
    
- 在 node 11 之后，不变的是 nextTick 比其他微任务先执行，但每执行完一个 setImmediate 宏任务，就执行微任务，再执行下一个 setImmediate，因此输出为
    
```jsx
// timeout1 => next tick1 => promise resolve => timeout2 => next tick2 => timeout3 => timeout4
```
        

### node 版本差异说明

这里主要说明的是 node11 前后的差异，因为 node11 之后一些特性已经向浏览器看齐了，总的变化一句话来说就是，如果是 node11 版本一旦执行一个阶段里的一个宏任务(setTimeout,setInterval和setImmediate)就立刻执行对应的微任务队列，同上一节中的例子。

### Node 和浏览器的 EventLoop 主要区别

浏览器中的微任务是在每个相应的宏任务中执行，而nodejs中的微任务是在不同阶段之间执行的。

### 思考拓展题

node的事件循环中，首次进入事件循环时，在poll阶段，有可能会跳到check阶段执行回调，但是check阶段在poll阶段之后，那么poll阶段是如何知道check阶段有没有回调需要执行的呢？

检查 setImmediate callback queue？

## 说说你对中间件的理解
中间件是介于**应用**系统和**系统**软件之间的一类软件，它使用系统软件所提供的基础服务（功能），衔接网络上应用系统的各个部分或不同的应用，能够达到资源共享、功能共享的目的。

在 NodeJS 中，中间件主要是指封装 http 请求细节处理的方法。在 koa 中，中间件的本质是一个回调函数，参数包含**请求上下文**（包含请求对象和响应对象）和执行下一个中间件的函数，在这些中间件函数中，我们可以执行业务逻辑代码，修改请求和响应对象、返回响应数据等操作。

KOA 是基于 NodeJS 当前比较流行的 web 框架，本身支持的功能并不多，功能都可以通过中间件扩展实现。通过添加不同的中间件，实现不同的需求，从而构建一个 koa 应用。

koa 中间件采用的是洋葱圈模型，每次执行下一个中间件传入两个参数：

- ctx: 封装了 request 和 response 的变量
- next: 进入下一个要执行的中间件的函数

### 总结
在实现中间件的时候，单个中间件应该足够简单，职责单一，中间件的代码编写应该高效，必要的时候通过缓存重复获取数据。

koa 本身比较简洁，但是通过中间件的机制能够实现各种所需要的功能，使得 web 应用具备良好的可扩展性和组合性。

通过将公共逻辑的处理编写在中间件中，可以不用在每一个接口回调中做相同的代码编写，减少了冗余代码，过程就如装饰者模式  

## KOA 洋葱模型了解吗？你觉得它是怎么实现的？
在洋葱模型中，每一层相当于一个中间件，用来处理特定的功能，比如错误处理、`Session` 处理等等。其先后顺序是 `next` 前请求，然后执行`next`函数，最后是`next`后响应，也就是说每一个中间件中都有两次处理时机。
通过洋葱模型，我们可以把核心业务逻辑和其他非核心功能分隔开，比如鉴权、日志、错误处理、请求分发等功能并不是核心业务功能，可以放到中间件中，提高了代码的可维护性和可扩展性。

怎么实现的？
- 一个属性 middlewares，用来存放中间件
- use 方法，用来新增中间件
- listen 方法，开启监听
- _handleRequest 方法，请求到来时，创建一个 Context，然后调用 _compose 方法来执行中间件。
- compose

1. use 方法 - 用来增加中间件
    
    通过 use 方法注册中间件，use 方法只做了一件事，就是把中间件 push 到中间件数组中
2. listen 方法 - 开启监听

    执行 `app.listen` 方法的时候，其实是用 `Node.js` 原生 `http` 模块 `createServer` 方法创建了一个服务
    
    ```js
    function listen(...args) {
        const server = http.createServer((req, res) => {
            this._handleRequest(req, res)
        })
        server.listen(...args)
    }
    ```
    
3. _handleRequest 方法

    请求到来时，创建一个 context, 然后调用 `_compose` 方法来执行中间件。
    
    ```js
    function _handleRequest(req, res) {
        const ctx = new Context(req, res)
        this._compose(ctx).then(() => {
            console.log('end')
        }).catch(console.log)
    }
    ```
    
4. compose 方法

    该方法是实现洋葱模型的关键
    
    ```js
    function _compose(ctx) {
        function dispatch(i) {
            if (i === this.middlewares.length) return Promise.resolve()
            const middleware = this.middlewares[i];
            const next = () => dispatch(i + 1)
            try {
                return Promise.resolve(middleware(ctx, next))
            } catch (e) {
                return Promise.reject(err)
            }
        }
        return dispatch(0)
    }
    ```

# 浏览器
## 说说 Cookie。Cookie 默认有效时间？怎么解决？
## 浏览器缓存（HTTP 缓存）
#### 1. 缓存位置

1. Service Worker

   Service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的。

2. Memory Cache

   存储在内存中的缓存，主要包含的是已经抓取到的资源，例如页面上下载的样式、脚本、图片等。

   内存缓存虽然高效，但是缓存持续性短，**一旦关闭 Tab 页面，缓存就被释放**。

3. Disk Cache

   存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中。比 Memory Cache 胜在容量和存储时效上。

   在所有浏览器缓存中，Disk Cache 覆盖面基本是最大的。它会根据 HTTP Request 中的字段判断哪些资源需要缓存，哪些资源可以不需要请求直接使用，哪些资源已经过期需要重新请求。并且即使在跨站点请求的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。绝大部分缓存都来自 Disk Cache。

   **浏览器会把哪些文件丢进内存中？哪些丢进硬盘中？**

   - 对于大文件来说，大概率是不存储在内存中的，反之优先
   - 当前系统内存使用率高的话，文件优先存储进硬盘

4. Push Cache

#### 2. 强缓存

不会向服务器发送请求，直接从缓存中读取资源，请求返回 200 状态码，并且 size 显示 from disk cache 和 from memory cache。

强缓存判断是否缓存的依据来自于**是否超过某个时间或者某个时间段**，而不关心服务器是否更新。

Cache-Control 优先级比 Expires 高。

##### Cache-Control

是 HTTP/1.1 的产物

- no-cache：不使用强缓存，使用缓存则需要经过协商缓存来验证决定；即需要验证是否需要更新数据
- no-store：不适用任何缓存
- must-revalidate：如果配置了 max-age 信息，当缓存仍然小于 max-age 时使用缓存，否则需要对资源进行验证。
- public：所有内容都将被缓存（客户端和代理服务器都可缓存）
- private：所有内容都只有客户端进行缓存
- max-age：`max-age=xxx` 表示缓存内容在 xxx 秒后失效

##### Expires

是 HTTP/1.0 的产物，是过时的产物，现阶段它的存在是一种兼容性的写法，在某些不支持 HTTP/1.1 的环境下，Expires 就会发挥用处。

#### 3. 协商缓存

强制缓存失效后，浏览器携带**缓存标识**向服务器发起请求，**由服务器根据缓存标识决定**是否使用缓存的过程就是协商缓存。主要有以下两种情况：

- 协商缓存生效就返回 304 状态码和 Not Modified
- 协商缓存失效就返回 200 状态码和请求结果

可以通过设置 Request Header 中添加 Last-Modified 或 Etag 实现。 

##### Last-Modified & If-Modified-Since

浏览器在第一次访问资源时，服务器返回资源的同时，在 `response header` 中添加 `Last-Modified` 的header，**值是这个资源在这个服务器上的最后修改时间**，浏览器接受后缓存文件和 header。浏览器下一次请求这个资源，检测到有 Last-Modified 这个 header，于是添加 ==If-Modified-Since== 这个header，值就是 `Last-Modified` 中的值；浏览器再次收到这个资源请求，会根据 `If-Modified-Since` 中的值与服务器中这个资源的最后修改时间进行对比。如果没有变化，返回 304 和空的响应体，直接从缓存中获取；反之，如果 `If-Modified-Since` 中的值小于服务器中这个资源的最后修改时间，说明文件有更新，于是返回资源文件和 200。

缺点：

- 如果本地打开缓存文件，即使文件没有被修改，还是会造成 `Last-Modified` 被修改，服务端不能命中缓存导致发送同样的资源
- 因为 `Last-Modified` 只能以秒计时，如果在不可感知的时间内修改完成文件，那么服务器还是会认为资源命中，不会返回正确的资源

##### Etag & If-None-Match

**Etag** 是服务器响应请求时，返回当前文件的一个唯一标识，只要资源有变化，`Etag` 就会重新生成。浏览器在下一次加载资源向服务器发送请求时，会将上一次返回的 `Etag` 值放到 Request header 里的 `If-None-Match` 字段中，服务器只需要比较该值是否与服务器上该资源的 `Etag` 值是否一致，就能很好的判断资源相对客户端而言是否被修改过。如果服务器发现 `Etag` 匹配不上，那么直接以常规的 GET 200 回包形式将新的资源（包括新的 `Etag`）发给客户端；如果 `Etag` 是一致的，则直接返回 304 知会客户端直接使用本地缓存即可。

##### 两者的优劣差异：

- 首先在精度上，Etag 要优于 Last-Modified，Last-Modified 时间单位是秒，如果某个文件在1s内改变了多次，那么他们的 Last-Modified 并不会体现出被修改；但是 Etag 每次都会改变确保了精度；如果是负载均衡的服务器，各个服务器产生的 Last-Modified 也有可能不一致。
- 其次是在性能上，Etag 要逊于 Last-Modified，毕竟后者只需要记录时间，而前者需要服务器通过算法计算出一个 hash 值。
- 第三体现在优先级上，服务器校验有限考虑 Etag。



#### 4. 缓存机制

强制缓存优先于协商缓存，若强制缓存失效则使用协商缓存。协商缓存是否生效由服务器决定，若失效则服务器返回 200，重新返回资源和缓存标识，再存入浏览器缓存中；若生效则返回 304，继续使用缓存。[link](#9、浏览器缓存机制)



#### 5. 实际场景应用缓存策略

##### (1) 频繁变动的资源

```
Cache-Control: no-cache
```

不使用强缓存，每次请求服务器，配合 `Etag` 或 `Last-Modified` 来验证资源是否有效。这种做法虽然不能减少请求数量，但是能显著减少响应数据大小。

##### (2) 不常变化的资源

```
Cache-Control: max-age=31536000
```

使用强制缓存，并给它们的 `Cache-Control` 设置一个很大的 `max-age=31536000(一年)`。为了解决更新的问题，就需要在文件名（或者路径）中添加 hash，版本号等字符，之后更改动态字符，达到更改引用的 URL 的目的，使用新的资源文件

#### 6、用户行为对浏览器缓存的影响

所谓用户行为对浏览器缓存的影响，指的就是用户在浏览器如何操作时，会触发怎样的缓存策略。主要有 3 种：

- 打开网页，地址栏输入地址： 查找 disk cache 中是否有匹配。如有则使用；如没有则发送网络请求。
- 普通刷新 (F5)：因为 TAB 并没有关闭，因此 memory cache 是可用的，会被优先使用(如果匹配的话)。其次才是 disk cache。
- 强制刷新 (Ctrl + F5)：浏览器不使用缓存，因此发送的请求头部均带有 `Cache-control: no-cache`(为了兼容，还带了 `Pragma: no-cache`),服务器直接返回 200 和最新内容。


## 关键路径渲染
浏览器在收到HTML,CSS,JS文件后，它是如何把页面呈现到屏幕上的？

![浏览器渲染过程.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7b4e7211-7c88-4df0-8cbd-a3bed1d5b794/浏览器渲染过程.png)

浏览器是一个边解析边渲染的过程。

- 浏览器解析HTML文件构建**DOM树**
- 解析CSS文件构建**样式树**
- 结合 DOM 树和 样式树合成**渲染树**
- 根据渲染树计算每一个节点的信息
- 根据计算好的信息绘制页面，这个过程涉及到 **Reflows & Repaints**

### HTML 文件解析过程

1. 浏览器接收到 HTML，立即开始解析（DOM 和 CSSOM 并行解析构建）;
2. 当遇到 `script` 标签（不考虑 `async` 和 `defer` 的情况），停止 HTML 解析，开始加载 js 文件（这个过程 CSS 的解析不受影响）;
3. 加载完后立即执行 JS 代码；当 JS 文件需要对样式进行操作时，若此时CSS 的解析还没完成，进入第四步；否则进入第五步
4. JS 的执行也阻塞（此时 HTML 的解析仍然被阻塞），直到 CSS 的解析完成后，再继续执行 JS 代码；
5. 等到 JS 代码执行完后，再继续 HTML 的解析。
6. DOM 树和 CSSOM 树构建完成，合成 render 树
7. 根据渲染树计算每一个节点的信息（布局）
   1. 布局：通过渲染树中渲染对象的信息，计算出每一个渲染对象的位置和尺寸
   2. 回流：在布局完成后，发现了某个部分发生了变化影响了布局，那就需要倒回去重新渲染。
8. 根据计算好的信息绘制页面
   1. 绘制阶段，系统会遍历呈现树，并调用呈现器的 “paint” 方法，将呈现器的内容显示在屏幕上。
   2. 重绘：某个元素的背景颜色，文字颜色等不影响元素周围或内部布局的属性变化时，会引起重绘。

### 解析 / 执行的优先级

HTML 文件中，DOM 和 CSSOM 并行解析构建，遇到 `<script>` 标签，js 的加载和执行都会阻塞 DOM 的构建，如果 js 加载完成后，CSSOM 解析还没有完成，那么 js 的执行会被阻塞，直到 CSSOM 解析完成，因为 JS 可以修改 CSS 样式；然后 js 执行完后，继续 DOM 的构建；

### 页面渲染流程

1. 构建 DOM 树
2. 样式计算
3. 布局定位
4. 图层分层
5. 图层绘制
6. 合成显示

在 CSS 属性改变时，重渲染会分为“回流”、“重绘”和“直接合成”三种情况，分别对应从“布局定位”，“图层绘制”和“合成显示“开始，再走一遍上面的流程。

元素的 CSS 具体发生什么改变，决定了上面的哪种情况：

1. 回流：元素位置、大小发生变化，导致其他节点受到影响，需要重新计算布局；
2. 重绘：修改了一些不影响布局的属性，例如颜色；
3. 直接合成：合成层的 transform、opacity 修改，只需要将多个图层再次合并，而后生成位图，最终展示到屏幕上；

### 渲染中的层

上面提到了渲染过程中会发生“图层分层”。浏览器中的层分为两种：“**渲染层**”和“**合成层**（也叫复合层）”。很多文章中还会提到一个概念叫“图形层”，其实可以把它当作合成层看待。

### 开发者工具中的 Layers

先直观的感受一下“层”，打开devTools 中的 layers:

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a814f723-a1e7-40fa-8968-e8dacd9848e3/Untitled.png)

可以看到 AB 元素都在最底下的图层中，元素 C 是单独的一层，元素 D 又是一层。

```html
<style>
  body{
    margin:0;
    padding:0;
  }
  .box {
    width: 100px;
    height: 100px;
    background: rgba(240, 163, 163, 0.4);
    border: 1px solid pink;
    border-radius: 10px;
    text-align: center;
  }
  #a {
  }
  #b {
    position: absolute;
    top:0;
    left: 80;
    z-index: 2;
  }
  #c {
    position: absolute;
    top:0;

    left: 160;
    z-index: 3;
    transform: translateZ(0);           // -- 分层 --
  }
  #d {
    position: absolute;
    top:0;

    left: 240;
    z-index: 4;
  }
  .description {
    font-size: 10px;
  }
</style>

<div id="a" class="box">A</div>
<div id="b" class="box">
  B
  <div class="description">z-index:2</div>
</div>
<div id="c" class="box">
  C
  <div class="description">z-index:3</div>
  <div class="description">transform: translateZ(0)</div>
</div>
<div id="d" class="box">
  D
  <div class="description">z-index:4</div>
</div>
```

之前说过，浏览器中的层分为两种，**渲染层**和**合成层**，在这里看到的全部都是合成层。那么怎样生成一个渲染层，又怎样才能形成一个合成层呢？

### 渲染层

渲染层的概念跟”[层叠上下文](https://www.notion.so/20-fd85b73278bb43a8a1853a19492e0db3)“密切相关。简单来说，拥有 z-index 属性的定位元素会生成一个层叠上下文，一个生成层叠上下文的元素就生成了一个渲染层。也就是说，形成渲染层的条件就是形成层叠上下文的条件，有这几种情况：

- document 元素
- 拥有 z-index 属性的定位元素
- 弹性布局的子项，并且 z-index 不是 auto
- opacity 非1的元素
- transform 非 none 的元素
- filter 非none 的元素
- will-change = opacity | transform | filter
- 需要剪裁的元素，也就是 overflow 不是 visible 的元素

### 合成层

在devtools 中看到的不是渲染层，而是形成层，只有一些**特殊的渲染层**会被提升为合成层，通常来说有这些情况：

1. transform:3D变换：translate3d, translateZ;
2. will-change:opacity | transform | filter
3. 对 opacity | transform | filter 应用了过渡和动画 （transition/animation）
4. video、canvas、iframe

可以看出，上面这些条件属于生成渲染层的”加强版“，也就是说形成合成层的条件要更苛刻。

用开头的例子，C元素就是命中条件1，使用了3D变换 transform: translateZ(0)，于是被提升到一个单独的合成层。

但是 D 元素没有命中上面任何一条规则，却也是一个单独的合成层。因为还有一种情况—隐式合成。

**隐式合成**

当出现一个合成层后，层级顺序高于它的堆叠元素就会发生隐式合成。

我们给 C、D 元素设置层级，z-index 分别是3和4；又在 C 元素上使用 3D 变换，提升成了合成层。此时，层级高于它的 D 元素就发生了隐式合成，也变成了一个合成层。

隐式合成出现的根本原因是，元素发成了堆叠，浏览器为了保证最后的展示效果，不得不把层级顺序更高的元素拎出来盖在已有合成层上面。

**层爆炸与层压缩**

隐式合成产生了很多预期外的合成层——页面中所有 z-index 高于它的节点全部被提升成合成层，这些合成层都是相当消耗内存和 GPU 的。

所以带给我们的启示是给合成层一个大的 z-index 值，避免出现隐式合成。

还好浏览器逐渐进行了优化，也就是层压缩机制——多个渲染层同一个合成层重叠时，会自动将他们压缩到一起，避免”层爆炸“带来的损耗。

### 硬件加速

硬件加速就是合成层会交给 GPU 去处理，在硬件层面上开外挂，比在主线程上效率更高。

就像在ipad上画画一样，画手都是在不同的图层绘制线稿、上色，这样才方便后期修改，不至于牵一发而动全身。提升成合成层的元素发生回流、重绘都只影响这一层，渲染效率得到提升。

这就是硬件加速的意义：进行性能优化时，经常会说减少回流、重绘，如果能直接避免当然时最好，但如果实在没法避免，可以使用硬件加速，让这个元素单独回流、重绘，**减少绘制的面积**。

有得必有失，开启硬件加速后的合成层会交给 GPU 处理，当图层过多时，将会占用大量内存，尤其在移动端会造成卡顿，让优化适得其反。正确使用硬件加速就是在渲染效率和性能损耗之间找到一个平衡点，让页面渲染迅速不白屏，又流畅丝滑。

### 优化渲染性能

**利用硬件加速，可以把需要重排/重绘的元素单独拎出来，减少绘制的面积**，除此之外，提升渲染性能还有几个常见的方法：

1. **避免重排/重绘**，直接进行合成，合成层的 transform 和 opacity 的修改都是直接进入合成阶段的；比如可以使用 transform: translate 代替 left/top 修改元素的位置；使用 transform:scale 代替宽高的修改；
2. **注意隐式合成**，给合成层一个较大的 z-index 值，虽然大部分浏览器已经实现了层压缩能力，但是依旧有无法处理的情况，最好的办法就是一开始就避免层爆炸；
3. **减小合成层占用的内存**，合成层的最大问题就是占用内存较多，而内存的占用和元素的尺寸是成正比的，如果要实现一个 100x100 的元素，可以给宽高都设置为 10px（10x10），再使用 transform:scale(10)放大十倍，这样占用的内存只有直接设置的 1/100。

## 浏览器进程与线程

CPU、进程、线程之间的关系：

- 进程 是 **cpu 资源分配**的最小单位
- 线程 是 **cpu 调度**的最小单位（线程是建立在进程的基础上的依次程序运行单位，一个进程中可以有多个线程）
- 不同进程之间也可以通信，不过代价较大
- 同一进程下的各个线程之间共享程序的内存空间(包括代码段、数据集、堆等)及一些进程级的资源(如打开文件和信号)。

浏览器是多进程的，一个 tab 页面就是一个独立的进程
### 浏览器进程

- 主进程：负责控制浏览器除标签页外的界面，包括地址栏、书签、前进后退按钮等，以及负责与其他进程的协调工作，同时提供存储功能
- GPU 进程：负责整个浏览器界面的渲染。使用 GPU 的初衷是为了实现 3D CSS 效果，只是后面网页、Chrome 的 UI 界面都用 GPU 来绘制，这使 GPU 成为浏览器普遍的需求，最后 Chrome 在多进程架构上也引入了 GPU 进程
- 网络进程：负责发起和接受网络请求
- 渲染进程，就是我们说的**浏览器内核**
    - 负责页面渲染，脚本执行，事件处理等
    - 排版引擎 Blink 和 JS 引擎 V8 都是运行在该进程中的
    - 每个 Tab 页面一个渲染进程
- 第三方插件进程
    - 每种类型的插件对应一个进程，仅当使用该插件时才创建

**tips**: 

1. 进程中任意线程出错，进程崩溃；
2. 线程共享进程内存空间；
3. 进程之间相互隔离但可以通信；
4. 在 A 页面打开 B 页面，而 A、B 属于同一个站点时，B 会复用 A 的渲染进程，此时一个页面崩溃，另一个页面也会崩溃（在地址栏直接输入地址打开的页面，不会共用进程）
5. 浏览器内核：
    1. chrome 内核 - Blink
    2. safari 内核 - Webkit
    3. Firefox 内核 - Gecko

### 渲染进程

- GUI 渲染线程
    - 负责渲染页面，布局和绘制
    - 页面需要重绘和回流时，该线程就会执行
    - 与 JS 引擎线程互斥，防止渲染结果不可预期
- JS 引擎线程
    - 负责处理解析和执行 JS 脚本程序
    - 只有一个 JS 引擎线程
    - 与 GUI 渲染线程互斥，防止渲染结果不可预期
- 事件触发线程
    - 用来控制事件循环（鼠标点击、setTimeout、ajax 等）
    - 当处理一些不能立即执行的代码时，会将对应的任务在其可触发的时机，添加到事件队列的末端
    - 事件循环机制会在 JS 引擎线程空闲时，循环访问事件队列的头部如果有函数，则会将该函数推到执行栈中并立即执行
- 定时触发器线程
    - setInterval 与 setTimeout 所在的线程
    - 定时任务并不是由 JS 引擎计时的，是由定时触发线程来计时的
    - 计时完毕后，将回调事件放入事件队列中
- 异步 http 请求线程
    - 浏览器有一个独立的线程用于处理 AJAX 请求
    - 当请求完成时，若有回调函数，将回调函数放入事件队列中

你知道僵尸进程和孤儿进程吗？

- 孤儿进程：父进程退出了，而它的一个或多个进程还在运行，那么这些子进程都会成为孤儿进程。这些孤儿都将被init进程收养，并负责这些孤儿的以后
- 僵尸进程：就是子进程比父进程先结束，而父进程又没有释放子进程占用的资源，那么子进程的描述还留在系统中，这种进程就是僵尸进程


## 浏览器渲染引擎有哪些

[1] IE浏览器 (trident内核)

[2] Mozilla firefox (gecko内核)

[3] Safari (webkit内核）

[4] Chrome (Blink内核)

[5] Opera (原为Presto内核，现为Blink内核)

# 安全
## XSS
Cross-Site Scripting（跨站脚本攻击）简称 XSS，是一种代码注入攻击。攻击者通过在目标网站上注入恶意脚本，使之在用户的浏览器上运行。利用这些恶意脚本，攻击者可获取用户的敏感信息如 Cookie、SessionId 等，进而危害数据安全。

XSS 的本质是：恶意代码未经过滤，与网站正常代码混在一起；浏览器无法分辨哪些脚本是可信的，导致恶意脚本被执行。

通过哪种方法“注入”恶意脚本的？
不仅仅是业务上的“用户的 UGC 内容”，包括 URL 上的参数等都可以是攻击的来源。在处理输入时，以下内容都不可信：

- 来自用户的 UGC 内容
- 来自第三方的链接
- URL 参数
- POST 参数
- Referrer （可能来自不可信的来源，要做白名单过滤）
- Cookie（可能来自其他子域注入）

### XSS 分类
根据攻击的来源，XSS 攻击可分为存储型、反射型和 DOM 型三种。
| 类型       | 存储区                  | 插入点*         |
| ---------- | ----------------------- | --------------- |
| 存储型 XSS | 后端数据库              | HTML            |
| 反射型 XSS | URL                     | HTML            |
| DOM 型 XSS | 后端数据库/前端存储/URL | 前端 JavaScript |

#### 存储型 XSS
攻击步骤：

1. 攻击者将恶意代码提交到目标网站的数据库中；
2. 用户打开目标页面时，网站服务器将恶意代码从数据库中取出，拼接在 HTML 中返回给浏览器；
3. 浏览器执行恶意代码；
4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定操作；

常见于带有用户保存数据的网站功能，如论坛发帖、用户私信等。

#### 反射型 XSS
攻击步骤：

- 攻击者构造出特殊的 URL，其中包含恶意代码
- 用户打开带有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出，拼接到 HTML 中返回给浏览器
- 浏览器执行恶意代码
- 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定操作。

反射型 XSS 和 存储型 XSS 的区别是：存储型 XSS 的恶意代码存在数据库中，反射型 XSS 的代码存在 URL 里。

反射型 XSS 常见于通过 URL 传递参数的功能

#### DOM 型 XSS
攻击步骤：

- 攻击者构造出特殊的 URL，其中包含恶意代码
- 用户打开带有恶意代码的 URL。
- 用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行
- 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定操作。

DOM 型 XSS 与前两种 XSS 的区别：DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞。

### XSS 攻击的预防
XSS 攻击有两大要素：

- 攻击者提交恶意代码
- 浏览器执行恶意代码

针对第一个要素，我们是否能够在用户输入的时候，过滤掉恶意代码呢？
#### 输入过滤
在用户提交时，前端过滤输入再提交给后端，是否可行？
答案是不可行，一旦攻击者绕过前端，直接构造请求，就可以提交恶意代码了

那么在后端写入数据库前，对输入进行过滤，然后把“安全的”内容返回，是否可行？
问题是，在提交阶段，我们不确定内容要输出到哪里。

- 用户的输入内容可能同时提供给前端和客户端，而一旦经过 escapeHTML() ，客户端显示的内容就变成了乱码
- 在前端中，不同位置所需的编码也不同
    - 当转译后的内容作为 HTML 拼接页面时，可以正常显示
    - 但是通过 Ajax 返回，然后赋值给 js 的变量时，前端得到的字符串就是转义后的字符。这个内容不能直接用于 Vue 等模板的展示，也不能直接用于内容长度计算。不能用于标题等。

所以输入侧过滤能够在某些情况下解决**特定**的 XSS 问题，但会引入很大的不确定性和乱码问题。在防范 XSS 攻击时应避免此类方法。

当然，对于明确的输入类型，进行输入过滤还是必要的。

既然输入过滤并不可靠，就要通过“防止浏览器执行恶意代码”来防范XSS。分为两类：

- 防止 HTML 中出现注入
- 防止 JS 执行时，执行恶意代码

#### 预防存储型和反射型 XSS
存储型和反射型 XSS 都是在服务端取出恶意代码后，插入到相应 HTML 里的，攻击者可以编写的内容被内嵌到代码中去，被浏览器所执行。
预防这两种漏洞，有两种常见做法：

- 改成纯前端渲染，把代码和数据分隔开
- 对 HTML 做充分转义

##### 纯前端渲染
过程

- 浏览器先加载静态 HTML，此 HTML 中不好含任何跟业务相关的数据
- 执行 HTML 中的 JavaScript。
- JS 通过 AJAX 加载业务数据，调用 DOM API 更新到页面上

纯前端渲染中，我们会明确告诉浏览器，下面要设置的内容时文本还是属性、还是样式等等。浏览器不会被轻易其变执行预期外的代码。

但还需注意避免 DOM 型漏洞，例如 onload 事件和 href 中的 javascrit:XXX 等

在很多内部、管理系统中，采用纯前端渲染是非常合适的。但对于性能要求高，或有 SEO 需求的页面（例如有 SSR），仍然要面对拼接 HTML 的问题

##### 转义 HTML
如果拼接 HTML 是必要的，就需要采用合适的转义库，对 HTML 模板各处插入点进行充分的转义。
当然，HTML 的编码是十分复杂的，在不同的上下文里要使用不同的转义规则。最好是使用业界比较成熟的模板引擎实现

#### 预防 DOM 型 XSS
DOM 型 XSS 攻击，实际上就是网站前端 JavaScript 代码本身不够严谨，把不可信的数据当作代码执行了。

在使用 `.innerHTML`、`.outerHTML`、`document.write()` 时要特别小心，不要把不可信的数据作为插入内容，而应尽量使用 `.textContent`、`.setAttribute()` 等

如果使用 Vue/React 并且不使用 `v-html`/`dangerouslySetInnerHTML` 功能，就在前端 render 阶段避免了 `innerHTML`、`outerHTML` 的 XSS 隐患。

DOM 中的内联事件监听器、`a`标签的 `href` 属性、JavaScript 的 `eval`、`setTimeout`、`setInterval` 等，都能把字符串作为代码运行。如果不可信的数据拼接到字符串中传递给这些 API，很容易产生安全隐患，务必避免。

#### 其他 XSS 防范措施
##### CSP
严格的 CSP 在 XSS 的防范中可以起到以下的作用：

- 禁止加载外域代码，防止复杂的攻击逻辑
- 禁止外域提交，网站被攻击后，用户的数据不会泄露到外域
- 禁止内联脚本执行
- 禁止未授权的脚本执行
- 合理使用上报可以
- 限制 `a` 标签 `href` 属性能够加载的资源的域名，或者禁止跨域，或者允许子域名等

可以在 meta 标签中使用 CSP 或在请求头中设置 CSP

##### 输入内容长度控制
对于不受信任的输入，限定一个合理的长度，增加 XSS 攻击难度

##### 其他安全措施
- HTTP-only Cookie：禁止 JS 读取某些敏感 Cookie，攻击者完成 XSS 注入后也无法窃取此 Cookie
- 验证码：防止脚本冒充用户提交危险操作

## CSRF
CSRF(Cross-site request forgery)简称：跨站请求伪造。

### CSRF 攻击原理

HTTP 是无状态协议，服务器只能根据当前请求的参数（包括 Head 和 Body 的数据）来判断本次请求需要达到的目的(Get 或者 Post 都一样)，服务器并不知道这个请求之前做了什么，这就是无状态。

但是现实有很多情况需要有状态，比如登录态的身份信息，网页上很多操作需要登录之后才能操作，比如相册的上传照片和删除照片等功能都需要登录之后才能操作。那么怎么判断登录态？（如果遇到这个问题你会怎么做？）其实解决方案都是类似的，只能是每次 HTTP 请求都把登录态信息（用 key 表示）传给后台服务器，后台通过 key 字段判断用户合法性之后再处理这个请求要处理的敏感操作。

怎么方便的让每个 HTTP 请求都携带登录态信息呢？所以就设计出了 Cookie, Cookie 的主要特性包括：

- 浏览器默认自动携带**本次 HTTP 请求域名的 Cookie**（不管是通过什么方式，在什么页面发送的 HTTP 请求）
- 读写 Cookie 有跨域限制
- 生命周期有会话和持久两种

#### CSRF 的攻击过程
根据上面介绍，登录态 Cookie 的 key 是浏览器默认自动携带的，key 通常是会话 Cookie，只要浏览器不关闭，Key 一直存在。所以只要用户 A 曾经登陆过网站，浏览器没有关闭，用户在没有关闭的浏览器打开一个黑客网站，黑客页面发送 HTTP 请求到网站的后台会默认带上网站的登录态 Cookie，也就能模拟用户 A 做一些增删改等敏感操作。Get 和 Post 都一样，这就是 CSRF 攻击原理。这种攻击过程也是最常见的攻击过程。

#### 读操作能否被攻击到？
上面说的增删改都是写操作，回对后台数据产生负面影响，所以是能被攻击的。而读操作具有**幂等性**，不会对后台数据产生负面影响，能否被攻击到？读操作也可能是敏感数据，当然由于跨域限制，默认大部分情况下是拿不到的，除了以下两种特殊情况：
- 如果后台返回的数据是 JSONP 格式，是能被黑客页面拿到的
- 如果后台是通过 CORS 处理跨域，而没有对请求的 Origin 做白名单限制，ACAO 响应头是*或者包含黑客页面，包括 Get/Post/Del 等操作，也是能被黑客页面拿到的。

除了这两种情况，读操作是不能被攻击到的，因为浏览器跨域限制是天然的安全的。

### CSRF 防护方法
知道攻击原理，防护方法也很简单，找到能够区分请求发送的页面时自己的页面还是黑客的页面的方法就可以了。

1. Referrer

    HTTP 请求头 Referrer 字段是浏览器默认带上的，含义是发送请求的页面地址，如果是从黑客页面发送出来的 Referrer 值就是黑客页面地址，所以后端只要通过 Referrer 做白名单判断就能防这种常见的 CSRF 攻击了。
    
    1. Referrer 会不会被伪造或篡改？
        - 在浏览器环境下，Referrer 是浏览器自己带上的，js 是改不了 Referrer的，所以是不能被伪造和篡改的。
        - 浏览器插件能改吗？可以，但是这不属于 CSRF 攻击范畴，如果用户浏览器都已经被安装了黑客插件了就有更方便的攻击方法，但是不可能在所有用户浏览器都安装上黑客的插件。
        - 通过网关或者抓包修改 Referrer 可行码？可行，但这是中间人攻击，也不属于 CSRF 范畴，防中间人攻击应该用 HTTPS。
        - 黑客通过自己后台代理，请求发送到黑客自己的后台，黑客后台修改 referrer 在转发到目标网站后台，可行吗？能改，但不可行，请求发送到黑客自己后台不会带上目标网站的 Cookie，登录态校验不通过，敏感操作做不了；
    2. 用 Referrer 防 CSRF 安全吗？

        除了下面几种特殊情况，用 Referrer 是安全的：
        
        - 读操作不能用 JSONP, CORS 要白名单过滤
        - 写操作 Referrer 为空时不能放过，使用白名单限制，Referrer 在白名单内采访过。那什么时候会为空？
            - 地址栏直接输入 url 的时候，第一个请求 Referrer 为空，一般是 html 页面，这种读操作不用防 CSRF。怎么过滤？一般页面请求头中包含 Accept: text/html, 请求方法为 GET, 就可以放开，同时要避免在页面请求中做其他操作，例如获取参数等，否则防范就失效了。
            - 使用 Referrer-Policy 策略设置 no-referrer 时，
            - 还有一些 iframe 的特殊使用等

        另外，写操作不能用 get，如果写操作可以用 get，由于 img 标签、a 标签能发送 get 请求，并且携带的 referrer 还是合法的，如果写操作用 get, 就会给后端带来危害。
        
    3. 用 origin 可以吗？

        可以的，原理跟 Referrer 是一样的，含义是发送请求页面的域名，主要目的是解决跨域问题的。如果用来校验 CSRF 请求，要处理一些细节：后台判断 origin 时要使用白名单，不在白名单内的请求都直接返回失败
        
2. Token - cookie-to-header approach

    上面讲到 Cookie 有跨域限制，所以我们可以利用这个特性来区分是自己的页面还是黑客页面。只要页面能读写 cookie，就证明是自己的页面。那么比较简单的方案就是服务器通过 cookie 下发一个 token, 该 token 通过加密算法对数据进行加密，一般 token 都包括随机字符串和时间戳的组合，页面发请求的时候从 cookie 取出 token 通过 HTTP 请求参数传给后台，后台比较参数里的 token 和 cookie 里的 token 是否一致，如果一致就证明是自己页面发的请求，否则返回失败。这种方法能够 100% 防 CSRF。
    DOUBLE
    
    1. Token 是前端产生还是后端产生？

        上面举例的例子是后端产生的，但其实后端没有存这个 token, 所以原则上前后端产生都可以，只要保证随机性。

        如果前端产生 token 然后写到 cookie 里，然后 HTTP 请求参数也带上 token, 后端逻辑一样，比对参数里的 token 和 cookie 里的 token 是否一致，如果一致就证明是自己页面发的请求。

        这就是 Cookie 读和写的差别，只要能读写自己域名的 Cookie 就是自己的页面
    2. 推荐的最佳实践方案

        由于登录态已经下发了一个 key，防 CSRF 的 token 就可以复用这个 key，由于登录态 key 比较重要，尽量避免明文暴露，所以前端拿到 key 后做了一次 hash 放到 http 请求参数中，后端通过同样的 hash 算法对 cookie 里的 key 做 hash 后跟参数里的 token 比对是否一致，如果一致就证明是自己页面发的请求，否则返回失败。Hash 算法简单高效就行。
    3. Token 放在 HTTP 参数里的哪里？

        放在 URL 的 querystring 里、Post请求的 Data 里，或者 HTTP 请求头里，这三种方式都可以：
        - 放在 querystring 中会影响 get 请求的缓存效果，因为重新登陆后 token 就变了，并且影响请求的语义化。
        - 如果放在 HTTP 请求头中，就需要使用 fetch 或者 XHR 发请求，这样会变成复杂请求，跨域时需要多一次 Option 预检请求，对性能多少有一点影响。
    4. 用 token 方案后写操作可以用 get 吗？

        可以，用了 token 之后，get 和 post 的安全等级是一样的，但是从语义化考虑建议 get 还是处理读操作方便。
    5. 用 token 后读操作可以用 JSONP 跨域吗？

        可以，
    6. 如果页面有 XSS 漏洞，黑客拿到了 cookie 怎么办？

        那就需要采取防御 XSS 的安全措施了，比如 CSP、用户输入输出做转义等。

    
3. 是否还有其他方案
    1. Cookie 的 SameSite 可以吗？

        Tips: 它用来标明这个 Cookie 是个“同站 Cookie”，同站Cookie只能作为第一方Cookie，不能作为第三方Cookie

        不好用，SameSite 有三个值，分别是 strict / lax / none，设置的太严格，会影响自己业务的体验，设置的太松没有效果，就算最严格 strict 模式，也放不了写操作的 get 请求等情况。
    2. Cookie 的 HTTPOnly 可以吗？

        不行，HTTPOnly 表示这个 cookie 只能是 HTTP 请求可以读写，js 没有读写权限，浏览器还是会带上，登录态校验还是通过的。且使用 HTTPOnly，上面的 Token 方案就用不了。
    3. 验证码可以吗？

        不行，验证码是用来防机器暴力攻击的，验证码是用来确认敏感操作是自然人发送还是机器自动发送的。

        大概原理就是前端通过 img 标签展示图片验证码给用户看，这个图片 HTTP 请求也会设置一个 cookie 包含加密的 codeId，用户输入后进行敏感操作的 HTTP 请求通过参数把用户输入的 code 传给后台，后台把 code 和 codeId 与数据库中做比较，如果一致则通过。

        而黑客同样可以在黑客的页面展示验证码给用户，通过诱导用户输入验证码完成攻击操作。你可能的改进方案：
        
        - 验证码图片做防盗链。黑客可以用 Referrer-Policy 的 no-referrer
        - no-referrer 不通过，就用 iframe 嵌入页面，只把页面的验证码区域展示出来
        - 页面不给 iframe 嵌入，这才成功防住。
            - 如何防止页面被内嵌：
	            
	            ```js
	                if (window !== window.top) {
	                    window.top.location.href = currentURL
	                }
	            ```
	            
            同样解决了点击劫持的安全问题
            
            - 防止页面嵌入黑客 iframe

            ```plain
                X-Frame-options: DENY | SAMEORIGIN
                // DENY: 不允许嵌入任何 iframe; SAMEORIGIN: 只允许嵌入同源 iframe
            ```

    4. HTTPS 可以吗？

        不行，HTTPS 是防中间人攻击的
    
    5. 不用 cookie 可以吗？

        可以，但是不推荐。
        
        - 方案一：登录态 key 不放在 cookie 中。所以 HTTP 请求也不会自动携带 key，也就不存在 CSRF 漏洞。但是对于大型复杂网站来说是非常棘手的，因为涉及到新开页面、多个页面之间登录态都需要同步。跨页面通讯也有多种方案，如果使用 localStorage 等本地缓存的话，关闭页面或者缓存满了还要清理缓存。总的来说会复杂很多，还不如用 Cookie。

        - 例如 CSRF Token - 不使用 cookie

        将 token 存放在服务端的 Sessions 中, 定义请求头 `csrftoken` 下发加密后的 token, 客户端每次请求都带上这个 token，服务端验证请求中的 token 是否包含与存储在 Sessions 中的值相匹配，并验证当前 token 的合法性，例如是否过期等。
        
        **分布式校验要怎么做呢？**

        在大型网站中，使用 Session 存储 CSRF Token 会带来很大的压力。访问单台服务器 Session 是同一个，但是现在大型网站中，我们的服务器通常不止一台，可能是几十台甚至几百台之多，用户发起的 HTTP 请求通常要经过像 Ngnix 之类的负载均衡器后，再路由到具体的服务器上，由于 Session 默认存储再单击服务器内存中，因此在分布式环境下同一个用户发送的多次 HTTP 请求可能会先后落到不同的服务器上，导致后面发起的 HTTP 请求无法拿到之前的 HTTP 请求存储在服务器中的 Session 数据，从而使得 Session 机制在分布式环境下失效，因此在分布式集群中 CSRF Token 需要存储在 redis 之类的**公共存储空间**。
        
        由于使用 session 存储，读取和验证 CSRF Token 会引起比较大的复杂度和性能问题，目前很多网站采用 Encrypted Token Pattern 方式。这种方法的 Token 是一个计算出来的结果，而非随机生成的字符串。这样在校验时无需再去读取存储的 Token，只用再次计算一次即可。这种 Token 值通常是使用 UserID、时间戳和随机数，通过加密的方式生成。这样既可以保证分布式服务的 Token 一致，又能保证 Token 不容易被破解。
        
        在 token 解密成功之后，服务器可以访问解析值，Token 中包含的 UserID 和时间戳将会被拿来验证有效性，将 UserID 与当前登录的 UserID 进行比较，并将时间戳与当前时间进行比较。

## SQL 注入
**如何防御**
严格限制Web应用的数据库的操作权限，给此用户提供仅仅能够满足其工作的最低权限，从而最大限度的减少注入攻击对数据库的危害

后端代码检查输入的数据是否符合预期，严格限制变量的类型，例如使用正则表达式进行一些匹配处理。

对进入数据库的特殊字符（'，"，\，<，>，&，*，; 等）进行转义处理，或编码转换。基本上所有的后端语言都有对字符串进行转义处理的方法，比如 lodash 的 lodash._escapehtmlchar 库。

所有的查询语句建议使用数据库提供的参数化查询接口，参数化的语句使用参数而不是将用户输入变量嵌入到 SQL 语句中，即不要直接拼接 SQL 语句。例如 Node.js 中的 mysqljs 库的 query 方法中的 ? 占位参数。

# TypeScript
## 说说你对类型推断的理解？
## type 和 interface 的区别
- 类型别名可以为任何类型引入名称。例如基本类型，联合类型等
- 类型别名不支持继承
- 类型别名不会创建一个真正的名字
- 类型别名无法被实现，而接口可以被派生类实现
- 类型别名无法重复声明，而接口重复声明会被合并

## TS 的装饰器是什么

装饰器是一种特殊类型的声明，它能够被附加到类声明、方法、访问器、属性或参数上。

装饰器组合：多个装饰器可以同时应用到一个声明上，它们的求值方式与复合函数相似。在这个模型下，当符合 f 和 g 时，复合的结果是 (f·g)(x)=f(g(x))

在 TS 里，当多个装饰器应用在一个声明上时会进行如下操作：

1. 由上至下依次对装饰器表达式求值 
2. 求值的结果会被当作函数，由下至上依次调用

- 类装饰器：在类声明之前被声明，应用于构造函数上，
- 方法
- 访问器
- 属性
- 参数

## TS 练习题
1. 以下代码为什么会提示错误，应该如何解决？
    
    ```ts
    type User = {
        id: number;
        kind: string;
    };

    function makeCustomer<T extends User>(u: T): T {
        // Error（TS 编译器版本：v4.4.2）
        // Type '{ id: number; kind: string; }' is not assignable to type 'T'.
        // '{ id: number; kind: string; }' is assignable to the constraint of type 'T', 
        // but 'T' could be instantiated with a different subtype of constraint 'User'.
        return {
            // solution: ...u
            id: u.id,
            kind: 'customer'
        }
    }
    ```
    
    原因：泛型约束于 `User` 类型，不局限于 `User` 类型，所以返回 T 类型不仅仅只有 `User` 类型的属性，可能还有其它属性
    
    解决：返回 `T` 类型的 u, 用 `User` 类型覆盖 `T` 中的 `id` 和 `kind`
    
2. 希望参数 a 和 b 的类型都是一致的，即 a 和 b 同时为 number 或 string 类型。当它们的类型不一致的值，TS 类型检查器能自动提示对应的错误信息。
    
    ```ts
        function f(a: string|number, b: string|number) {
            if (typeof a === 'string') {
                return a + ':' + b
            } else {
                return a + b
            }
        }
    ```
    
    解法：
    
    1. 函数重载

        ```ts
            function f(a: string, b: string): string;
            function f(a: number, b: number): number;
            function f(a: string|number, b:string:number): string|number {
                if (typeof a === 'string') {
                    return a + ':' + b
                } else {
                    return (a as number) + (b as number)
                }
            }

            f(2, 3) // OK
            f(1, 'a') // Error
            f('a', 2) // Error
            f('a', 'b') //ok
        ```
        
    2. 把参数组合成一种类型

        ```ts
        const isStrArr = (a: string[] | number[]): a is string[] => typeof a[0] === 'string'
        function f(...args: string[] | number[]) {
            is (isStrArr(args)) {
                return args[0] + ':' + args[1]
            } else {
                return args[0] + args[1]
            }
        }
        f(2, 3); // OK
        f(1, 'a'); //Error
        f('a', 2)// error
        f('a', 'b')
        ```
        
3. 定义一个 `SetOptional` 工具类型，支持把给定的 keys 对应的属性变成可选的。

    ```ts
    type Foo = {
        a: number;
        b?: string;
        c: boolean;
    };
    type SomeOption = SetOptional<Foo, 'a'|'b'>
    /**
     *  type SomeOption = {
     *      a?: number;
     *      b?: string;
     *      c: boolean;
     *  }
     */ 
    ```
    
    解题：
    
    ```ts
    type SetOptional<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;
    type SetOptionalOmit<T, K extends keyof T> = Pick<T, K> & Partial<Omit<T, K>>;
    type SetRequired<T, K extends keyof T> = Omit<T, K> & Required<Pick<T, K>>;
    type SetRequiredOmit<T, K extends keyof T> = Pick<T, K> & Required<Omit<T, K>>
    ```
    
4. `Pick<T, K extends keyof T>` 的作用是将某个类型中的子属性挑出来，变成包含这个类型部分属性的子类型。定义一个 `ConditionalPick` 工具类型，支持根据指定的 `Condition` 条件来生成新的类型：

    ```ts
    interface Example {
        a: string;
        b: string | number;
        c: () => void;
        d: {};
    }；
    type StringKeysOnly = ConditionalPick<Example, string>;
    //=> {a: string}
    type ConditionalPick<T, V> = {
        [K in keyof T as (T[K] extends T ? K : never)]: T[K]
    };// [K in keyof T] 相当于遍历了 keys, 然后执行后面的语句，只取有效的 K
    // or 
    type PickKeys<T, K> = {
        [k in keyof T]: T[k] extends K ? k : never;
    }[keyof T]; // a | never | never | never

    type ConditionalPick<T, K> = {
        [k in PickKeys<T, K>]: T[k];
    }; // {a:string}
    ```
    
    as 子句的相关文档介绍：https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html#key-remapping-in-mapped-types

    With this new `as clause`, you can leverage features like template literal types to easily create property names based off of old ones. And you can even filter out keys by producing never. That means you don’t have to use an extra Omit helper type in some cases.
5. 定义一个工具类型 `AppendArgument`，为已有的函数类型增加指定类型的参数，新增的参数名是 `x`，将作为新函数类型的第一个参数。具体的使用示例如下所示：

    ```ts
        type Fn = (a: number, b: string) => number;

        type FinalFn = AppendArgument<Fn, boolean>;
        // (x: boolean, a: number, b: string) => number
        type AppendArgument<F extends (...args: any) => any, A> = (x: A, ...args: Parameters<F>) => ReturnType<F>;
        // 使用 infer
        type AppendArgument<F extends (...args: any) => any, A> = (x: A, ...args: Parameters<F>) => ReturnType<F>;
        
    ```
6. 实现一个 ts 的工具函数 `GetOnlyFnProps<T>` ，其中 T 属于一个对象。提取泛型 T 中类型是函数的工具函数，其中 T 属于一个对象。

    ```ts
        type GetOnlyFnKeys<T extends object> = {
            [K in keyof T]: T[K] extends Function ? K : never
        };
        type GetOnlyFnProps<T extends object> = {
            [K in GetOnlyFnKeys<T>]: T[K]
        }
    ```
7. 实现一个 ts 的工具函数 `UnGenericPromise<T>` ，提取 Promise 中的泛型类型

    ```ts
        type UnGenericPromise<T extends Promise<any>> = T extends Promise<infer U> ? U : never;
    ```

## typeof 操作符
`typeof` 操作符可以用来获取一个变量或对象的类型，包括函数对象

**const 断言**

当使用 const 断言构造新的字面量表达式时，可以向编程语言发出以下信号：

- 表达式中的任何字面量类型都不应该被扩展；
- 对象字面量的属性，将使用 `readonly` 修饰；
- 数组字面量将变成 `readonly` 元组，还可以通过 `typeof` 操作符获取元组中元素值的联合类型：

    ```ts
    let y = [10, 20] as const
    typeof y[number] // 10 | 20
    ```
    这同样适用于包含普通对象的数组：
    ```ts
    const locales = [{ locale: "zh-CN" }]
    typeof locales[number]["locale"]// "zh-CN"
    ```

要注意的是 `const` 只适用于简单的**字面量表达式**，且上下文不会立即将表达式转换为完全不可变

## 说说你对 TS 的泛型的理解
## interface 和 enum 编译之后会变成什么？
typescript 是静态类型的语言，interface 只是用来在编译阶段进行静态类型分析，在编译成 js 之后就消失了。

enum 会被编译成一对对象，分别是 key-value 和 value-key 的映射

- enum 可以被遍历吗？会有什么问题？

    可以被遍历，但是它编译后的结果是一对对象，会存在顺序问题，对象的遍历顺序基于 v8 引擎的实现


# 前端架构
## 前后端分离
是一种架构模式，通过 nginx+tomcat 的方式（中间也可以加个 Node 中间件）有效的进行解耦，并且前后端分离会为以后的多端化服务打下坚实基础。

其核心思想是前端 html 页面通过 ajax 调用后端的 restful api 接口并使用 json 数据进行交互。
前端项目与后端项目是两个项目，放在两个不同的服务器，需要独立部署，两个不同的工程，两个不同的代码库，不同的开发人员。

前后端工程师需要约定交互接口，实现并行开发，开发结束后需要进行独立部署。

前端只需要关注页面的样式与动态数据的解析 & 渲染，而后端专注于具体业务逻辑。

- 为什么要前后端分离？
    - 实现前后端解耦，提供多端化服务
    - 职责分离，关注点分离
    - 开发效率提升，前后端并行开发
    - 发现 bug，可以快速定位问题
    <!-- - 在大并发的情况下，可以同时水平扩展前后端的服务器 -->
    - 减少后端服务器的并发 / 负载压力。除了接口以外的其他所有请求全部转移到前端服务器上。
    - 即使后端服务器暂时超时或宕机了，前端页面也会正常访问，只不过来自后端的数据刷不出来而已。
    - 在 nginx 中部署证书，外网使用 HTTPS 访问，并且只开放 443 和 80 端口，其他端口一律关闭，内网使用 http，性能和安全都有保障。
    - 前端大量的组件代码得以复用，实现组件化，提升开发效率
- 这种架构方式的缺点是什么？
    1. 逻辑前置化，大量的 control 逻辑交给了前端，使得前端变重了
    2. SEO 问题，但是可以通过 SSR 解决
- Restful API 是目前前后端分离的最佳实现
    1. restful api 是一种规范，作为开发时的标准
    2. 轻量，直接通过 http 进行 get/post/put/delete 等操作
    3. 面向资源，一目了然，具有自解释性。比如看请求头 delete 就知道是删除操作
    4. 数据描述简单，一般通过 json 或者 xml 做数据通信

## 了解 webpack 打包过程吗？比如从入口文件到目标文件中间发生了什么？
Webpack 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程：

1. **初始化参数**：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数。
2. **开始编译**：用上一步得到的参数**初始化 Compiler 对象**，加载所有配置的插件，执行对象的 **run** 方法开始执行编译；
3. **确定入口**：根据配置中的 entry 找出所有的入口文件
4. **编译模块**：从入口文件出发，调用所有配置的 **Loader** 对模块进行编译，编译完成后会生成抽象语法树 AST，通过 **AST** 就可以分析这个模块是否还有依赖的模块，进而继续循环执行下一个模块的编译解析。
5. **完成模块编译**：在经过第四步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系。
6. **输出资源**：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 chunk，再把每个 **chunk** 转换成一个单独的文件加入到输出列表，这一步是可以修改输出内容的最后机会。
7. **输出完成**：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。

在以上过程中，会通过**发布订阅模式**，向外抛出一些 **hooks**，而 webpack 的 **plugins** 插件即可通过监听这些关键的事件节点，插件可以调用 webpack 提供的 API 改变输出结果，执行插件任务进而达到**干预输出结果**的目的。
    
简单来说：

- 初始化：启动构建，读取与合并配置参数，加载 Plugin，实例化 Compiler。
- 编译：从 Entry 出发，针对每个模块串行调用对应的 Loader 去编译文件的内容，再通过生成的 AST 找到该模块依赖的模块，递归地进行编译处理。
- 输出：将编译后的模块组合成 chunk, 将 chunk 转换成文件，输出到文件系统中。

其中文件的解析与构建是一个比较复杂的过程，在 webpack 源码中主要依赖于 **compiler** 和 **compilation** 两个核心对象实现。

compiler 对象是一个全局单例，他负责把控整个 webpack 打包的构建流程。compilation 对象是每一次构建的上下文对象，它包含了当此构建所需要的所有信息，每次**热更新**和**重新构建**，compiler 都会重新生成一个 compilation 对象，负责此次更新的构建过程。

而每个模块间的依赖关系，依赖于 AST。每个模块文件在通过 Loader 解析完成之后，会（通过 acorn 库）生成模块代码的 AST，通过 AST 就可以分析这个模块是否还有依赖的模块，进而继续循环执行下一个模块的编译解析。

- module, chunk 和 bundle 的区别是什么？
    - module 是入口文件以及它们的依赖，只要是文件，都是 module
    - chunk 是 webpack 指定的用于表示是一组在 webpack 构建过程中的 module，会根据依赖引用关系生成 chunk
    - bundle 就是 webpack 处理好 chunk 文件后，最后输出的结果，包含已完成加载编译的源文件的最终版本，可以直接在浏览器中运行。一般是和 chunk 一对一的关系，但也有例外，比如我们使用 `MiniCssExtractPlugin` 抽离 chunk 中的 css 到单独的文件中。
    
    一句话总结就是：
    module，chunk 和 bundle 其实就是同一份逻辑代码在不同转换场景下的取了三个名字：

    我们直接写出来的是 module，webpack 处理时是 chunk，最后生成浏览器可以直接运行的 bundle。 

## Restful
Restful API 是目前前后端分离的最佳实现

1. restful api 是一种规范，作为开发时的标准
2. 轻量，直接通过 http 进行 get/post/put/delete 等操作
3. 面向资源，一目了然，具有自解释性。比如看请求头 delete 就知道是删除操作
4. 数据描述简单，一般通过 json 或者 xml 做数据通信

## 说说 webpack 打包过程有什么优化手段
1. 使用高版本的 Webpack 和 Node.js
2. 构建分析
 - 速度分析：`speed-measure-webpack-plugin` 测量 Webpack 构建速度，并给出测量报告的输出。
 - 体积分析：`webpack-bundle-analyzer` 在 Webpack 构建结束后生成构建产物体积报告，配合可视化的页面，能够直观知道产物中的具体占用体积。
3. 缩小构建目标：
 - 优化 `resolve.modules` 配置：通过指定解析模块所在的目录，以减少模块搜索层级
 - 优化 `resolve.extensions` 配置：自动解析确认的后缀扩展
 - 合理使用 `alias`：创建 import 或 require 的别名，来确保模块引入变得更简单。相当于直接告诉 Webpack 去哪个路径下查找，减小搜索范围。
4. 预编译资源模块
 - 脚本外链分包 `externals` 引入第三方模块包，将基础包通过 CDN 引入，不打入 `bundle` 中，项目中通过 `script-loader!` 引入这些第三方模块包
5. 充分利用缓存提升二次构建速度：v5 自带缓存能力(`config.cache` 默认为 true)，缓存生成的 webpack 模块和 chunk
 - babel-loader 开启缓存 (`cacheDirectory: true`)
 - terset-webpack-plugin 开启缓存 (v4 `cache: true`)
 - 使用 cache-loader 或者 hard-source-webpack-plugin
6. 多进程/多实例优化：
 - 构建
   - HappyPack
   - thread-loader
   - terser-webpack-plugin 开启 `paralle` 参数
 - 多进程并行压缩
   - webpack-paralle-uglify-plugin
   - uglifyjs-webpack-plugin 开启 `paralle` 参数（不支持 ES6）
   - terser-webpack-plugin 开启 `paralle` 参数
7. CSS 文件分离和压缩：
 - 生产环境通过 `mini-css-extract-plugin` 将 css 代码从 bundle 中分离出来，这样可以使用 CSS/JS 文件的并行加载。
 - 开发环境用 `style-loader`, 因为它可以使用多个标签将 CSS 插入到 DOM 中，并且反应更快
 - 使用 `css-minimizer-webpack-plugin` 对 CSS 文件进行压缩，默认只在生产环境下使用，开发化境可以设置 `minimize` 值
8. 生产环境充分利用 `contenthash` 命名文件，配合浏览器协商缓存使用
9. 图片压缩
 - 配置 image-webpack-loader (imagemin)
10. 提取页面公共资源
 - 基础包分离：
   - 使用 html-webpack-externals-plugin 将基础包通过 CDN 引入，不打入 bundle 中
   - 使用 SplitChunksPlugin 进行（公共脚本、基础包、页面公共文件）分离，生产环境下默认开启
11. Dll:
 - 使用 DllPlugin 进行分包，使用 DllReferencePlugin(索引链接) 对 manifest.json 引用
 - HashedModuledIdsPlugin 可以解决模块数字 id 问题
12. Tree Shaking：
13. 动态 Polyfill：通过分析请求头信息中的 UserAgent 实现自动加载浏览器所需的 polyfill。
14. Scope hoisting - 生产环境下默认开启

## 是否写过 Loader？简单描述一下编写 Loader 的思路
Webpack 最后打包出来的成果是一份 JavaScript 代码，实际上在 webpack 内部默认也只能够处理 JS 模块代码，在打包过程中，会默认把所有遇到的文件都当作 JavaScript 代码进行解析，因此当项目存在非 JS 类型文件时，我们需要先对其进行必要的转换，才能继续执行打包任务，这也是 Loader 机制存在的意义。

Loader 是支持以数组的形式配置多个的，因此当 webpack 在转换文件类型的时候，会按顺序链式调用每一个 loader，前一个 loader 返回的内容会作为下一个 loader 的入参。因此 loader 的开发需要遵循一些规范，比如返回值必须是标准的 JS 代码字符串，以保证下一个 loader 能够正常工作，同时在开发上需要严格遵循“单一职责”的原则，只关心 loader 的输入与输出。

loader 函数中的 this 上下文由 webpack 提供，可以通过 this 对象提供的相关属性，获取当前 loader 需要的各种信息数据。

## 是否写过 plugin？简单描述一下编写 plugin 的思路？
如果说 Loader 负责**文件转换**，那么 plugin 便是负责**功能扩展**。

Webpack 是基于发布订阅模式的，那么在运行的生命周期中会广播出许多事件，通过监听这些事件，就可以在特定的阶段执行自己的插件任务，从而实现自己想要的功能。

既然是基于发布订阅模式，那么知道 webpack 到底提供了哪些事件钩子供插件开发者使用是非常重要的，上文提到的 compiler 和 compilation 是 webpack 两个非常核心的对象，其中 compiler 暴露了和 webpack 整个生命周期相关的钩子（**compiler-hooks**），而 compilation 则暴露了与模块和依赖有关的粒度更小的事件钩子（**compilation hooks**）。

Plugin 的开发和开发 Loader 一样，需要遵循一些开发上的规范和原则：

- 插件必须是一个函数或者是一个包含 apply 方法的对象，这样才能访问 compiler 实例；
- 传给每个插件的 compiler 和 compilation 对象都是同一个引用，若一个插件中修改了它们的属性，会影响到后面的插件；
- 异步的事件需要在插件处理完任务时调用回调函数通知 webpack 进入下一个流程，否则会卡住；

## 说说 webpack 的 loader 和 plugin 的区别
首先 Webpack 最后打包出来的成果是一份 JavaScript 代码，实际上在 webpack 内部默认也只能够处理 JS 模块代码，在打包过程中，会默认把所有遇到的文件都当作 JavaScript 代码进行解析，因此当项目存在非 JS 类型文件时，我们需要先对其进行必要的转换，才能继续执行打包任务，这也是 Loader 机制存在的意义。

如果说 Loader 是负责**文件转换**，那么 Plugin 则负责**功能扩展**。在 webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。

## tree shaking 有了解吗？

Tree shaking 字面意思就是“摇树”，通常指通过打包工具“摇”我们的代码，将未引用代码(dead code)“摇”掉。在 Webpack 项目中，有一个入口文件，就相当于一棵树的主干，入口文件有很多依赖的模块，相当于树枝，虽然依赖了某些模块，但其实只使用了其中某些方法，通过 Tree Shaking，将没有使用的方法摇掉，这样来达到删除无用代码（包括未使用的函数消除和未使用的 JSON 数据消除）的目的。

**原理**
Tree Shaking 在去除代码冗余的过程中，程序会从入口文件出发，扫描所有的模块依赖，以及模块的子依赖，将它们连接起来形成一个 AST. 虽然，运行所有代码，查看哪些代码是用到过的，做好标记。最后再将 AST 中没有用到的代码删除。

前提是模块必须采用 ES6 Module 语法，因为 Tree Shaking 依赖 ES6 的静态语法：import 和 export。不同于 ES6 Module, CommonJS 支持动态加载模块，在加载前是无法确定模块是否有被调用。

*Tips: 如果项目中使用了 babel 的话，@babel/preset-env 默认将模块转换成 CommonJS 语法，可以设置 module: false;关闭。*

**sideEffects**
sideEffects 允许 tree shaking 跳过整个模块/文件和整个文件子树，配置在 package.json 中，sideEffects 主要是让 Webpack 这种 bundler 知道此项目是否可以做 Tree Shaking 的动作。

如果知道有哪些文件是不能做 tree shaking 的（比如 React 的 HOC），只要在 sideEffects 内用一个数组将这些文件路径写上去，这样在做 tree shaking 时，就会直接跳过这些文件。

**useExports**
如果说 sideEffects 在做的事情是跳过某个模块的 tree shaking, 那么 useExports 做的事情就是把树枝上没有用到的树叶移除，所以 useExports 其实才是在做真正的 tree shaking。

useExports 利用 terser 这套工具进行项目的 side effects 侦测，假如打包过程中发现既没有 side effects 且某些代码有没有被引用到，则该代码就会在之后的 uglify 被移除，借此达到真正的 tree shaking 效果。

## sourceMap
sourceMap 是一项将编译、打包、压缩后的代码**映射回源代码**的技术，由于打包压缩后的代码并没有阅读性可言，一旦在开发中报错或者遇到问题，直接在混淆代码中 debug 问题会带来非常糟糕的体验。sourceMap 可以帮助快速定位到源代码的位置，提高我们的开发效率。

在开发环境中，以下选项比较合适：

- eval - 每个模块都会使用 eval() 执行，并且都有 *//@ sourceUrl*。此选项会非常快地构建。主要缺点是，由于会映射到转换后的代码，而不是映射到原始代码，所以不能正确的显示行数。
- eval-source-map - 每个模块使用 eval() 执行，并且 sourceMap 转换为 DataUrl 后添加到 eval() 中。初始化 sourceMap 时比较慢，但是在重新构建时提供比较快的速度，并且生成实际文件。行数能够正确映射，因为会映射到原始代码中。它会生成用于开发环境的最佳品质的 sourceMap。
- eval-cheap-source-map - 类似于 eval-source-map。这是 "cheap" 的 sourceMap，因为它没有生成列映射，只是映射行数，它会忽略源自 loader 的 sourceMap，并且仅显示转译后的代码。
- eval-cheap-module-source-map - 类似 eval-cheap-source-map，并且在这种情况下，源自 loader 的 sourceMap 会得到更好的处理结果。然而，loader source map 会被简化为每行一个映射。

在生产环境中，以下选项比较合适：

- none - 忽略 devtool 选项，不生成 source map
- source-map - 整个 source map 作为一个单独的文件生成。它为 bundle 添加了一个引用注释，以便开发工具知道在哪里可以找到它。

`css-minimizer-webpack-plugin`: 仅对 devtool 配置项的 source-map、inline-source-map、hidden-source-map 与 nosources-source-map 值生效。

## css-loader 和 style-loader 的区别
- css-loader 的作用是把 css 文件进行转码
- style-loader 的作用是将 css-loader 内部样式注入到 HTML 页面的 style 标签中

## 前端性能优化，首屏渲染优化思路
### 思路
#### 缩短网络请求耗时
- **DNS** - `<link ref="dns-prefetch" href= />`
- **HTTP** 
  - 减少请求数量
  - 使用更高版本的 HTTP 如 HTTP/2
    - 基于二进制分帧的多路复用、头部压缩、请求优先级、服务端推送
    - 不需要担心如何减少 HTTP 请求，反而讲究传输轻量、细粒度的资源，以便独立缓存和并行传输。
  - 较小请求/响应体积
    - 开启 gzip 压缩请求文件
    - webpack 插件 `CompressionPlugin` 开启 gzip 压缩
    - Nginx 配置 / node 服务引入 `compression` 包
- **webpack**
  - JavaScript: `UglifyPlugin`
  - CSS: `MiniCssExtractPlugin`
  - HTML: `HtmlWebpackPlugin`
  - 提取公共代码 - `CommonsChunkPlugin`
  - 抽取组件的 CSS - 利用`extract-text-webpack-plugin` 将所有组件的 css 提取到同一个文件（如果使用 HTTP/2 不建议怎么做，反而影响缓存粒度）
  - 降低图片质量 - `image-webpack-loader` 放在 `file-loader` 后面
- **浏览器缓存**
  - 强缓存 - Expired, Cache-Control
  - 协商缓存
    - Last-Modified - If-Modified-Since
    - ETag - If-None-Match
  - 缓存策略
    - HTML 使用协商缓存
    - CSS、JS 和图片使用强缓存，文件命名带上 hash
    - 利用 Webpack 提供的三种 hash 计算方式，改变 hash 值，这样在更新版本的时候文件名称 hash 值更新，浏览器就请求新的路径，就不会命中强缓存。
      - hash：跟整个项目的构建相关，构建生成的文件 hash 值都是一样的，只要项目文件更改，整个项目构建的 hash 值都会更改
      - chunkhash：根据入口文件进行依赖文件解析、构建对应的 chunk，生成对应的 chunkhash
      - contenthash: 由文件内容产生的 hash 值，内容不同产生的 contenthash 值不同。   
- **CDN** - 总体原则：通过分布式的边缘网络节点，缩短资源到终端用户的访问延迟。加速图片、视频等大体积静态资源的加载

#### 浏览器渲染
- 避免 CSSOM 构建阻塞。将 css 放在 `head` 标签中，让它尽早被下载，充分利用并行构建 DOM 和 CSSOM。通过 CDN 加快 CSS 资源请求速度。
- 避免 JS 阻塞 - JS 的加载会阻塞 DOM 树构建（但不影响 CSSOM 的构建），加载完后等待 CSSOM 构建完毕才执行 JS 脚本。
  - 用 defer 模式加载执行 JS，该模式下的 JS 脚本会异步加载 JS 文件，并且在 HTML 解析完毕后才执行(DOMContentLoaded 之后执行)。
- 减少回流和重绘
- CSS
  1. 避免使用 table 布局
  2. 尽可能在 DOM 树的最末端改变 class
  3. 避免设置多层内联样式
  4. 将动画效果应用到 position 属性为 absolute 或 fixed 元素上
  5. 通过 transfrom 和 opacity 生成合成层，这些属性的修改会直接进入合成阶段；（减少合成层占用的内存，合成层的最大问题就是占用内存较多，而内存的占用和元素尺寸是成正比的，如果要实现一个 100 × 100 的元素，可以给宽高设置为 10px，再使用 `transfrom:scale(10)` 放大十倍，这样占用的内存只有设置的 `1/100`。
  6. 避免使用 CSS 表达式
- JavaScript
  1. 避免频繁操作样式，最好能够**一次性**重写 style 属性，或者将样式列表定义为 class 并一次性更改 class 属性
  2. 避免频繁操作 DOM
     1. 创建一个 documentFragment，在它上面应用所有 DOM 操作，最后把它添加到文档中。
     2. 也可以先将元素设置为 `display:none;`，操作结束后再把它显示出来。
  3. 避免频繁读取会引发回流/重绘的属性，有必要的话就将值用一个变量存起来
  4. 对具有复杂动画的元素使用绝对定位，使它**脱离文档流**，否则会引起父元素及后续元素频繁回流。
- 减少渲染量
  - 分片渲染：其思想是建立一个队列，通过定时器来进行渲染。
  - 虚拟列表：只渲染可见区域
  - 惰性加载：无限滚动
  - 按需加载：页面只在切换过去时才加载
- 硬件加速
- 减少渲染次数，避免重复渲染
- 图片懒加载：在页面中，先不给图片设置路径，只有当图片出现在浏览器的可视区域时，才去加载真正的图片，这就是延迟加载。
但是要注意的是，
- 使用 CSS3 代替图片
- 使用 webp(pronounced as weppy) 格式的图片

#### 改善 JS 性能
- 避免添加大量 JS 动画
- 节流和防抖避免一些重操作被频繁触发
- 缓存复杂计算，例如 vue-computed、react-memo
- 避免覆盖原生方法。原生方法是用 C/C++ 写的，运行速度会快很多
- Web Worker
- WebAssembly

#### SSR - 首屏加载优化，直接在服务端拼接好静态标签
#### Vue 项目性能优化
- 路由懒加载；Vue 是单页面应用，可能会有很多的路由引入，这样使用 `webpack` 打包后的文件很大，首次加载页面时加载的资源过多。如果能把不同路由对应的组件切割成不同的代码块，然后当路由被访问的时候才加载对应的组件，就更加高效，大大提高首屏渲染的速度。例如在 vue 项目中可以使用路由懒加载；React 可以使用 React.lazy 配合 Suspend 使用。
- 第三方插件的按需引入，例如 `element-ui`, 可以借助 `babel-plugin-component`，然后只引入需要的组件，以达到减小项目体积的目的。

### 网络请求优化
1. 减少 DNS 查询时间

    用 HTML 头部的 `<link rel="dns-prefetch" />` 提前获取 DNS 记录
2. 静态资源使用 CDN

    内容分发网络是一组分布在多个不同地理位置的 Web 服务器。服务器离用户越远，延迟越高。CDN 就是为了解决这一问题，在多个位置部署服务器，让用户离服务器更近，从而缩短请求时间。
3. 利用浏览器缓存

    将资源存储在用户的本地浏览器缓存中，除了产生了一个 304 Not Modified 响应之外，避免了任何形式的数据在网络上传输。
4. 最小化 HTTP 请求

    尽可能减小传输的数据大小，最小化 cookie、url 和查询字符串的大小
5. 最小化 HTTP 响应大小

    最小化 HTML、CSS 和 JavaScript 文件的大小，优化图像，并通过 gzip 压缩资源
6. 避免不必要的重定向

### 代码压缩
1. 开启 gzip 压缩

    gzip 编码是一种用来改进 web 应用程序性能的技术，web 服务器和浏览器必须共同支持 gzip，gzip 压缩效率非常高，通常可以达到 70% 的压缩率。
2. webpack 压缩

    在 webpack 中可以使用如下插件进行压缩：
    
    - JavaScript: `UglifyPlugin`
    - CSS: `MiniCSSExtractPlugin`
    - HTML: `HtmlWebpackPlugin`

    当然还可以做得更好，那就是使用 gzip 压缩，可以通过向 http 请求头中的 Accept-Encoding 添加 gzip 标识来开启这一功能。当然服务端也得支持。

    webpack 中加入 `CompressionPlugin` 插件开启 gzip 压缩
    如果服务端是 node 服务，可以在中间件中插入 `compression` 这个包

### 页面渲染优化 - 涉及到关键路径渲染
1. 避免 CSS 阻塞

    DOM 和 CSSOM 是并行解析构建的，只有这两个元素都构建完后，才能构建渲染树。浏览器在解析 HTML 的过程中，会从上到下进行解析，解析到 `link` 标签或者 `style` 标签时，CSSOM 的构建才开始。因此我们应该尽早的引入 CSS，使 CSSOM 能充分利用与 DOM 并行构建。也就是建议把 css 放在 head 标签里，并启用 CDN 实现静态资源加载速度优化
2. 避免 JS 阻塞

    在浏览器解析 HTML 的过程中如果遇到了 script 标签，会暂停渲染过程，将控制权交给 JS 引擎。JS 引擎对内联的 JS 代码会直接执行，对外部 JS 代码还要先获取脚本再执行。等 JS 引擎运行完毕，浏览器又会把控制权交给渲染引擎，再继续 DOM 和 CSSOM 的构建。

    我们可以通过 defer 的方式加载 script，不会阻塞 HTML 解析，等到 DOM 生成完毕且 script 加载完毕再执行 JS。
    
3. 使用字体图标 **iconfont** 代替图片图标

    字体图标就是将图标制作成一个字体，体积特别小
4. 降低 CSS 选择器的复杂度
5. 减少回流和重绘
    1. CSS
        1. 避免使用 table 布局
        2. 尽可能在 DOM 树的最末端改变 class
        3. 避免设置多层内联样式
        4. 将动画效果应用到 position 属性为 absolute 或 fixed 元素上
        5. 避免使用 CSS 表达式
    2. JavaScript
        1. 避免频繁操作样式，最好能够**一次性**重写 style 属性，或者将样式列表定义为 class 并一次性更改 class 属性
        2. 避免频繁操作 DOM，创建一个 documentFragment，在它上面应用所有 DOM 操作，最后把它添加到文档中。也可以先将元素设置为 display:none，操作结束后再把它显示出来，因为在 display 属性为 none 的元素上进行的 DOM 操作不会引发回流和重绘。
        3. 避免频繁读取会引发回流/重绘的属性，有必要的话就将值用一个变量存起来
        4. 对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。
6. 使用 flexbox 而不是较早的布局模型
7. 图片资源优化
    1. 使用雪碧图
    2. 降低图片质量
        1. webpack 插件 image-webpack-loader，只要在 file-loader 之后加入这个插件即可
    3. 图片懒加载
    
        在页面中，先不给图片设置路径，只有当图片出现在浏览器的可视区域时，才去加载真正的图片，这就是延迟加载。
    4. 使用 CSS3 代替图片
    5. 使用 webp 格式的图片

### JavaScript 性能优化
1. 不要覆盖原生方法 - 原生方法是用 C/C++ 写的，运行速度会快很多
2. 使用事件委托（简化 DOM 操作）
3. 避免添加大量的 JS 动画，CSS 动画和 Canvas 动画都比 JS 动画性能好。使用 `requestAnimationFrame` 来代替 `setTimeout` 和 `setInterval`，因为前者可以在正确的时间进行渲染，后者无法保证渲染时机。

### Webpack 优化
1. 提取公共代码

    - 避免相同的资源被**重复加载**，浪费用户的流量和服务器成本
    - 每个页面需要加载的**资源太大**，导致网页首屏加载缓慢，影响用户体验。

    所以我们需要将多个页面的公共代码抽离成单独的文件，来优化以上问题。Webpack 内置了专门用于提取多个 chunk 的公共部分的插件 **CommonsChunkPlugin**, 在我们的项目中，它的配置如下：
    
    ```js
        // 所有在 package.json 中依赖的包，都会被打包进 vendor.js 文件中
        new webpack.optimize.CommonsChunkPlugin({
            name: 'vendor',
            minChunks: function(module, count) {
                return (
                    module.resouce &&
                    /\.js$/.test(module.resource) &&
                    module.response.indexOf(path.join(__dirname, '../node_modules')) === 0
                )
            }
        })
        // 抽取出代码模块的映射关系
        new webpack.optimize.CommonsChunkPlugin({
            name: 'manifest',
            chunks: ['vendor']
        })
    ```

2. 模板预编译

    当使用 DOM 内模板或 JS 内字符串模板时，模板会在运行时被编译为渲染函数。预编译模板最简单的方式就是使用单文件组件--相关的构建设置会自动把预编译处理好，所以构建好的代码已经包含了编译出来的渲染组件，而不是原始的模板字符串。
    如果使用 webpack，并且喜欢分离 JS 和**模板文件**，可以使用 **vue-template-loader**, 它可以在构建过程中把模板文件转换成渲染函数。

3. 提取组件的 css

    当使用单文件组件时，组件内的 CSS 会以 style 标签的方式通过 JS 动态注入。如果使用服务端渲染，会导致“无样式内容闪烁”。将所有组件 CSS 提取到一个文件可以避免这个问题，也会让 CSS 更好地进行压缩和缓存。
    webpack + vue-loader (vue-cli 的 webpack 模板已经预先配置好)

4. 按需加载代码：vue 中路由懒加载

    Vue Router 支持开箱即用的动态导入，component 配置接收一个 Promise 组件的函数，Vue Router 只会在第一次进入页面时才会获取这个函数，然后使用缓存数据。（这意味着你可以用更复杂的方式返回一个 Promise）

    配合 webpack 使用时，可以将某个路由下的所有组件都打包在同个异步块中。只需要使用命名 chunk，一个特殊的注释语法来提供 chunk name：
    
    ```js
    const UserDetails = () =>
        import(/* webpackChunkName: "group-user" */'./UserDetails.vue')
    const UserDashboard = () =>
        import(/* webpackChunkName: "group-user" */'./UserDashboard.vue')
    const UserProfileEdit = () =>
        import(/* webpackChunkName: "group-user" */'./UserProfileEdit.vue')
    ```
    
    webpack 会将任何一个异步模块与相同的块名称组合到相同的异步块中。


## 前端工程化

首先，前端工程化的目标是解放生产力，提高开发效率。通过指定一系列的规范，借助工具和框架解决前端开发以及前后端协作过程中的痛点和难度问题，前后端分离是实现前端工程化的基础。

### 如何实施前端工程化

明确前后端开发的分工，是实现前后端分离的第一步，也是后端实现前端各种优化方案的基础。前端工程师主要负责的内容包括：

- 静态资源和动态资源的处理
- JavaScript 实现前端业务逻辑
- HTML 模板文件的产出；
- 中间层 Web 服务，一般由 Node.js 实现
- 前端单元测试；
- 前端项目部署；

其中，静态资源包括 .js 文件、.css 文件以及各种格式的图片、媒体文件等，这些文件不依赖于服务器，只需要再浏览器里面解析就可以了；
动态资源是指 HTML 的模板，如果项目不是由服务器完成渲染的 SPA 应用，那我们就要考虑如何实现 HTML 模板的渲染了。
前端项目部署是指静态资源文件在测试服务器上的部署，以及 HTML 模板文件在 Node.js 中间层服务器上的部署。

从**项目开发**的整体环节来说，实现前端工程化还需要熟练掌握下面几个方面：

#### 1. 使用 Webpack 实现项目构建

构建，简单来说就是编译，前端开发的所有文件最终归属是要交给浏览器去解析、渲染，并将页面呈现给用户，构建就是将前端开发中的所有源代码转化为宿主浏览器可以执行的代码。前端构建产出的资源文件只有三种，HTML、CSS、JS 文件。需要完成编译的内容由：
- 无法被浏览器直接识别的 JS 代码，包括 ES6+ 等符合 ECMAScript 规范的 JS 代码；
- 无法被浏览器直接识别的 CSS 代码，包括 SASS/LESS 等预编译的 CSS 语法；
- 无法被浏览器识别的 HTML 模板代码，包括 ejs、mustache 等 Node.js 模板引擎等；

项目构建其实就是为了弥补浏览器自身的缺陷和不足，是一种面向语言的编译过程。那么，除了针对语言本身之外，前端的构建还应该考虑到 Web 应用的**性能优化**，这些优化主要是为了减少 HTTP 请求数量/大小（HTTP/2 不需要考虑请求数量问题），提升用户体验，包括：

- 依赖打包，将同步依赖的文件打包在一起，减少 HTTP 请求数量；
- 资源嵌入，例如将小于 10kb 的图片编译为 base64 格式嵌入文档，减少 HTTP 请求数量；
- 文件压缩，减小文件体积
- 为文件加入 hash 指纹，以应对浏览器缓存策略
- 将开发环境下的域名与静态资源文件路径修改为生产环境下的域名和路径
- 文件名称的改变


#### 2. 使用 Babel 完成 JavaScript 编译(@babel/preset)
JavaScript 可以说是前端最为核心的一门编程语言了，JS 本身是可以直接在浏览器中执行的，那么为什么还要使用 Babel 再编译依次呢？其实，在 ES6 正式发布以后，前端工程师关注的重心就由 JS 转向了 ES。
ECMAScript 是一个标准，JavaScript 是对 ECMAScript 标准实现的一个子集。

Babel 的作用简单来说，就是将浏览器未实现的 ECMAScript 规范语法转化为可运行的低版本语法，例如将 ES6 的 class 转化为 ES5 的 prototype 实现。

#### 3. CSS 预编译(SASS/LESS)
在如今追求用户极致体验的潮流下，CSS 的开发要求不断提高，复杂的 CSS 开发变成了一件非常繁琐和痛苦的事情。最主要的原因还是受限于浏览器的实现和 CSS 本身的弱编程能力。

CSS 预编译器的工作原理是提供便捷的语法和特性供开发者编写源代码，随后经过专门的编译工具将源码转化为 CSS 语法。

#### 4. 模块化开发
模块化属于架构层面的概念，前端工程化与模块化的关系就类似于组装车间与零件的关系。使用模块化开发，可以解决下面几个问题：

- 避免命名冲突；
- 便于依赖管理；
- 利于性能优化；
- 提高可维护性；
- 提高代码可复用性；

在 ES6 规范发布之前，前端模块化开发主要有三种规范，分别是：CommonJS、AMD、CMD。

CommonJS 是一种只适用于 JavaScript 的静态模块化规范，适合 Node.js 开发，但并不适合浏览器环境，因为它是同步加载模块的，同步就意味着阻塞，会导致浏览器渲染被阻塞；而 AMD/CMD 规范并不是完全一致的，但核心功能是统一的，两个规范都重点解决了浏览器对前端模块的需求。

ES Module 规范推出之后，前三者的模块化规范也逐渐退出前端的历史舞台。ES Module 是语言层面的规范，与应用场景无关，所以一个不涉及运行环境 API 调用的模块可以在任何场景下运行。但是目前浏览器还没有完全支持这种规范，所以，要实现 ES6 Module 规范的话，还需要使用构建工具编译。

#### 5. 组件化开发
前面提到了模块化，组件化和模块化是两个完全不同的概念，模块化是文件层面上对代码和资源的拆分，组件化是设计层面上对 UI 的拆分。从 UI 中拆分出来的一个结构单元，称为 UI 组件一个 UI 组件单元包含 HTML、CSS、JS 逻辑。在页面的设计过程中，页面上的每一个元素都是组件，页面也是一个组件，只不过页面是一个大型组件，然后这个大型组件又由多个中小型组件拼接而成。中型组件还可以再拆分成小型组件，小型组件再拆分成 DOM 元素，DOM 元素也属于浏览器自身的组件，是组件的基本单元。这种组件化开发就是前端开发的“分治思想”。

#### 6. 开发环境的本地服务器与 Mock 服务 (webpack & GraphQL)

在前端工程化开发中，通过构建工具可以将代码进行编译，然后在浏览器中进行调试，但是在开发过程中源码的每次修改都需要执行一次构建，构建完成后才能在浏览器里运行，这对前端工程师来说无疑是一种灾难。要完美的解决这个问题，可以使用本地服务器和构建工具结合，对源码进行监听并在修改之后触发动态构建，使用自动化构建的方式代替人工。这种动态构建是使用本地服务器解决开发层面上的问题。

Mock 服务解决的是前后端协作开发的问题，前后端开发人员提前约定好规范，前端开发工程师通过本地服务器提供的 Mock 数据接口辅助前端逻辑的编写和功能模块的开发。如果项目中需要服务端渲染（SSR），本地服务器还需要具备解析 HTML 模板的能力，同时 Mock 服务提供 SSR 所需的初始化数据。

前端工程师可以使用本地服务器提供的 Mock 数据接口，在后端人员开发的同时，进行前端逻辑的**并行开发**，等到后端真实接口开发完成后，将前端请求的地址从 Mock 服务迁移到服务器的生产环境即可。

#### 7. 规范化约束 (例如 eslint / prettier)
无论是服务端开发还是前端工程化开发，规范化的约束都至关重要。开发人员在设计项目的整体架构时，为了考虑到项目的可扩展性、可维护性、高内聚性等因素，会对代码进行封装，使用配置化操作，为项目开发带来便利，这必然要求业务代码编程规范遵循既定的约束。这种约束虽然带来了开发上的便捷，但是在一定程度上制约了代码的可移植性。

#### 8. 项目部署流程化
站在前端开发的范畴来说，项目部署是指前端开发人员将构建产出的代码包部署到测试服务器的过程，而并非时将测试完成的代码发布到生产环境的过程。在部署过程中，要考虑目标服务器、路径信息是否与项目一一对应，并且可供负责部署到生产环境的开发人员进行配置，部署的操作流程应尽量简单。

在部署流程中，使用命令行取代工具执行本地部署，能够极大的提高部署的速度和效率，但是这只是初级阶段的部署流程。考虑到团队协作和安全的方面，最佳的方式应该是搭建一个可供严格审查、队列控制、操作简单的部署平台，并且有专人负责掌握流程进度。（Gitlab）虽然这种搭建部署平台的方式在一定程度上减缓了整体的部署速度，但是加强了团队协作和安全保障。

## 说说你对 BFF 的理解
BFF是（Backends For Frontends）单词的缩写，主要是用于服务前端的后台应用程序，来解决多访问终端业务耦合问题。

如果我们的接口同时提供给web、移动端使用，移动端仅用来采集数据以及数据的展示，而web端大多数场景是用来管理数据，因为不同端点的业务有所不同每一个端的接口复用度不会太高。

针对多端共用服务接口的场景，我们将基础的数据服务与BFF进行了分离，数据服务仅提供数据的增删改查，并不过多涉及业务的判断处理，所有业务判断处理都交给BFF来把控，遇到的一些业务逻辑异常也同样由BFF格式化处理后展示给访问端点。为每一个端点都提供一个BFF，每个端点的BFF处理自身的业务逻辑，需要数据时从基础服务内获取，然后在接口返回之前进行组装数据用于实例化返回对象。

这样基础服务如果有新功能添加，BFF几乎不会受到影响，而我们如果后期把App端点进行拆分成Android、IOS时我们只需要将app-bff进行拆分为android-bff、ios-bff，基础服务同样也不会受到影响。

这样每当新增一个访问端点时，我们需要修改的地方也只有网关的转发以及添加一个BFF即可，基础服务内提供的服务接口我们完全可以复用，因为基础服务提供的接口都是没有业务针对性的。

缺点：

- 响应事件延迟（服务如果是内网之间访问，延迟时间较低）
- 增加代码工作量
- 业务异常处理
- 分布式事务

    
# TODO

首屏时间是如何算的。有哪些相关的优化指标要知道。这是优化目的
找出能量化你重构的 tree-table 组件渲染速度的指标 FID?
然后才是找相关的优化方案进行优化
哪些问题会导致白屏？
是 js 运行时间过长，还是 ssr 加载失败导致的
如果能举出具体的case就好了
优化的方案千篇一律

SSR 原理



七层网络模型：应用层、表现层、会话层、传输层、网络层、数据链路层、物理层
五层网络模型：应用层、传输层、网络层、数据链路层、物理层

- [X] 鉴权类型？

    - 纯 cookie
    - cookie + session

        session 是会话的意思，浏览器第一次访问服务端，服务端就会创建一次会话，在回家中保存标识该浏览器的信息。它与 cookie 的区别是 session 是缓存在服务端的，cookie 则是缓存在客户端的，它们都由服务端生成，为了弥补 HTTP 协议无状态的缺陷

        - 认证方式
            1. 服务端在接收客户端首次访问时在服务端创建 session，然后保存 session （一般保存在 redis 中，推荐使用后者），然后给这个 session 生成一个唯一的标识字符串，在响应头中种下这个唯一表示字符串。
            2. 签名，这一步通过密钥对 sid 进行签名处理，避免客户端修改 sid。（非必须步骤）
            3. 浏览器中收到请求响应的时候会解析响应头，然后将 sid 保存在本地 cookie 中，浏览器在下次 http 请求的请求头中会带上该域名下的 cookie 信息。
            4. 服务端在接收客户端请求时回去解析 cookie 中的 sid，然后根据这个 sid 去找服务端保存的对应的 session，判断请求合法性。
      - 怎么在公司内部共享 session?
        - 存储在公共存储空间中，例如 redis
      - 缺点
        - 局限于在浏览器中使用（因为 cookie）
        - 为了满足全局一致性，最好把 session 存储在 redis 中做持久化，分布式环境下使用**加密令牌模式(Encrypted Token Pattern)**，保证分布式服务的 Token 一致，在 token 解密后，服务器将验证 token 信息的有效性，比如 token 中的 UserID 和时间戳与当前时间进行比较
    - token
      - 认证流程
        - 客户端使用用户名和密码请求登录
        - 服务端收到请求，去验证用户名和密码
        - 验证成功后，服务端会签发一个 Token，再把这个 Token 发送给客户端
        - 客户端收到 Token 后把它存储起来，之后每次向服务端请求资源都带上这个 Token
        - 服务端收到请求，然后去验证请求中的 Token (Authorization 请求头)，若验证失败返回 401 错误码
      - 与 session 的区别是？
        1. session-cookie 的缺点
           1. 认证方式局限于浏览器中使用，cookie 是浏览器端的机制，如果在 app 端就无法使用 cookie；
           2. 为了满足全局唯一性，最好把 session 存储在 redis 中做持久化，而在分布式环境下需要在每个服务器上都备份，占用了大量的存储空间。（也可以通过**加密令牌模式**）
           3. 在不是 HTTPS 协议下使用 cookie，容易收到 CSRF 攻击
        2. token 的缺点
           1. 加解密消耗使得 token 认证更消耗性能
           2. token 比 sessionId 大，更占宽带
        3. 两者区别
           1. token 认证不局限于 cookie，这样就使得这种认证方式可以支持多种客户端，而不仅是浏览器。且不受同源策略的影响
           2. 不使用 cookie 就可以规避 CSRF 攻击
           3. token 不需要存储，token 中包含了用户信息，服务端变成了无状态，只需要根据定义的规则校验这个 token 是否合法就行。这也使得 token 的可扩展性更强。
      - JWT
        - 组成
          - Header - 元数据（token 类型，加密算法）
          - Payload - 实际数据
          - Signature - 对前面两部分的签名，防篡改
        - 特点
          - 默认是不加密的，但也是可以加密的。生成原始 Token 以后，可以用私钥再加密一次。
          - 不加密的情况下，不能将秘密数据写入
          - 不仅可以用于认证，也可以用于交换信息。有效使用 JWT, 可以降低数据库查询次数
          - 最大的缺点是，由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token, 或者更改 token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。
          - JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT 的有效期应该设置得比较短，对于一些比较重要的权限，使用时应该再次对用户进行认证
          - 为了减少盗用，JWT 不应该使用 HTTP 传输，要使用 HTTPS

- [X] 前端权限控制

    - 接口权限 - 采用 jwt 的形式来验证，没有通过的话一般返回 401，跳转到登陆页面重新登录；通过 axios 请求拦截器进行拦截，每次请求的时候头部都带 token。
    - 路由权限 - 在路由守卫中进行拦截，如果跳转目标页面在免登录白名单中，直接跳过校验；否则，根据用户权限判断是否能够访问目标页面。
    - 菜单权限
      - 菜单与路由分离，菜单由后端返回
      - 菜单和路由都由后端返回
    - 按钮权限
      - 在页面中获取用户权限，根据用户权限决定是否 disable 或隐藏
      - 通过 vue 指令实现
- [ ] 用户登录密码加密方式

    几种常用的传输时加密情况：
    1. 前端加密，后端加密
    2. 前端加密，后端不加密
    3. 前端不加密，后端加密

    一些想法：
    1. 首先，密码不应当存储为明文或可逆加密的密文
    2. 前端加密会泄漏加密方式
    3. 前端不加密，用 `https`, 后端也不加密，只保存 hash
    4. 前端可逆加密，后端不可逆加密
    5. 后端数据加密是强制性的，否则无法通过公安备案

    加密算法和 hash 算法的区别：
    - 加密算法：加密算法是可逆的，用来对敏感数据进行保护。散列算法（签名算法、哈希算法）是不可逆的，主要用于身份认证。
    - hash 算法：hash 算法不是加密算法，只是单项的，没有解密过程。哈希的作用是把一个更大空间的数据映射到另一个空间。所以又叫算暗纹。

    实际情况：
    - 知乎：提交时密码加密，但是输入后在控制台还可以在 input 标签的 value 里看到明确的值
    - 掘金：提交时密码加密，控制台属性中不可见
    - qq 空间：登录页是 iframe，登录时通过 script 调用接口，前端密码加盐加密，控制台中看不见
- [ ] 怎么定义 shuffle 算法的随机性是否可靠？让你写一个测试代码的话你会怎么写？

    定义：数组的每种排列方式的出现概率是相同的，就可以认为随机性是可靠的
    
    实现一个测试代码的思路：
    - 创造一个有序数组，并求出它所有可能的排列方式
    - 运行足够多次(100w次) shuffle 算法，统计每种排列方式出现次数，计算误差率，小于 5% 视为可靠。
- [ ] 

# 计算机基础相关
## 进程与线程的区别
- **定位方式**：进程是计算机管理运行程序的一种方式，一个进程下包含一个或者多个线程。
- **角色方式**：进程是资源分配的基本单位，线程是程序执行的基本单位
- **资源共享方面**：进程之间不能共享资源，同一个进程下的多个线程共享所在进程的地址空间和其他资源。同时线程还有自己的栈和栈指针，程序计数器等寄存器。
- **性能开销方面**：线程上下文调度/切换比进程上下文切换要**快得多**
- **通信方面**：进程间通信 IPC, 线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。
## 并发和并行的区别
并发，指的是多个事情，在同一时间段内同时发生了。  
并行，指的是多个事情，在同一时间点上同时发生了。

并发的多个任务之间是互相抢占资源的。  
并行的多个任务之间是不互相抢占资源的、

只有在多CPU的情况中，才会发生并行。否则，看似同时发生的事情，其实都是并发执行的。
## 同步与异步
- 同步就是指一个进程在执行某个请求的时候，若该请求需要一段时间才能返回信息，那么这个进程将会一直等待下去，直到收到返回信息才继续执行下去；
- 异步是指进程不需要一直等下去，而是继续执行下面的操作，不管其他进程的状态。 当有消息返回时系统会通知进程进行处理，这样可以提高执行的效率。
- 
